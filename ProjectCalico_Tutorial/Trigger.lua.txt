local json = require "json"

-- Initialization (Object) Helper Functions
function Item(itemName, itemTooltip,itemCount, itemImage, itemCost,itemFlags)
    if(itemImage == nil) then
        itemImage = "icon_enhance_potiondealer_healing_potion"
    end
    if(itemCost == nil) then
        itemCost = 10
    end
    return {name = itemName, count = itemCount, image = itemImage, cost = itemCost, tooltip = itemTooltip, flags = itemFlags}
end

function EnemyType(enemyName, enemyDifficulty, enemyDescription, enemyFlags)
    return {name = enemyName, difficulty = enemyDifficulty, description = enemyDescription, flags = enemyFlags}
end

function EnemyIsElite(enemyLink)
    return enemyLink.flags ~= nil and enemyLink.flags.elite == true
end

function EnemyIsNightmare(enemyLink)
    return enemyLink.flags ~= nil and enemyLink.flags.nightmare == true
end

function Affinity(affinityName, affinityPassiveText,affinityIcon, affinityRequiredBonusCount, affinityBonusText, requireExactCount, affinityHasDedicatedBehavior)
    local needsExactNum = false
    if(requireExactCount ~= nil) then
        needsExactNum = requireExactCount
    end
    if(affinityHasDedicatedBehavior == nil) then
        affinityHasDedicatedBehavior = true
    end
    return {name = affinityName, passiveDescription = affinityPassiveText ,description = affinityBonusText,hasDedicatedBehavior = affinityHasDedicatedBehavior, image = affinityIcon, requiredCount = affinityRequiredBonusCount, requireExactCount = needsExactNum}
end

function HeroType(heroName, heroTrait, heroAbility, heroIcon)
    return {name = heroName, description = "Trait: "..heroTrait.."\n\nSpecial Ability: "..heroAbility, image = heroIcon, affinities = {}}
end

function DoNothing()
end

function MapEvent(eventName, eventDesc, eventChoice1, eventChoice1Desc,eventChoice1Callback, eventChoice2, eventChoice2Desc,eventChoice2Callback, eventChoice3, eventChoice3Desc,eventChoice3Callback)
    if(eventChoice3Callback == nil) then eventChoice3Callback = DoNothing end
    return {name = eventName, description = eventDesc, image = nil, choices = {eventChoice1, eventChoice2,eventChoice3 },
    choiceDescriptions = {eventChoice1Desc, eventChoice2Desc,eventChoice3Desc },
    choiceCallbacks = {eventChoice1Callback, eventChoice2Callback,eventChoice3Callback }
    }
end

function DisplayBehavior(behaviorName, behaviorIcon, behaviorDesc, showStacks)
    return {name = behaviorName, description = behaviorDesc, image = behaviorIcon, stacks = showStacks}
end

function Room(roomID, roomType, wasExplored, roomConnections)
    return {type = roomType, explored = wasExplored, connections = roomConnections, id = roomID}
end

function GamePerk(perkName, perkDesc, perkImage, applyBehavior, canStack  ,requiredDungeonLevel)
    if(requiredDungeonLevel == nil) then
        requiredDungeonLevel = 0
    end
    if(canStack == nil) then
        canStack = false
    end
    if(applyBehavior == nil) then
        applyBehavior = false
    end
    return {name = perkName, description = perkDesc, image = perkImage, stackable = canStack, levelNeeded = requiredDungeonLevel, isBehavior = applyBehavior}
end


function GetTableSize(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function foreach(collection, callback)
    for index=1,GetTableSize(collection) do
        callback(collection[index])
    end
end

function Clamp(number, min, max)
    if(number >= min and number <= max) then return number end
    if(number < min) then return min end
    return max
end


function GetDistanceBetweenPoints(pointOne, pointTwo)
    return math.sqrt( ((pointOne.x - pointTwo.x)^2) + ((pointOne.y - pointTwo.y)^2))
end

function GetSquaredDistanceBetweenPoints(pointOne, pointTwo)
    return ((pointOne.x - pointTwo.x)^2) + ((pointOne.y - pointTwo.y)^2)
end


function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

--[[function EnemyHasFlag(enemy, flagNameToCheck)
    enemy.flags
end]]
local encodedData = DCEI.Save.Get("DungeonData")
local dungeonData = nil
if(encodedData == nil) then
    dungeonData = {difficulty = 4, isHeroic = false, type = "Standard",zone = 2}
else
    dungeonData = json.decode(encodedData)
end

DCEI.LogMessage("Got dungeon difficulty: "..dungeonData.difficulty)
-- VARIABLES
local core = GameModules["Arcade/Core"]
local settings = {
    helpTips = true,

}
local testMode = false
local demonstrationMode = false
local targetingModeActive = false
local currentConversation = nil
local currentConversationStage = 1
local convoState = {0,0,0,0,0,0,0,0,0,0}
local party = {} -- List of heroes the player controls.
local partyUnits = {"Berserker"}

local partyUnitHealth = {}
local partyUnitPosition = {}
local PARTY_SIZE = 1

local HERO_CHOICE_LEVELS = {1,3,6,9}
local earnsHeroThisLevel = false --If set to true, the player will be able to pick a hero the next time they win a battle, regardless of if it's a hero choice level or not.

local battleOngoing = false
local heroicLevel = 0
local snapOffset = {x=0,y=-0.35}
local defaultSpawns = { --[[{12,20.5},{9.5, 20.3}, {14.6,20.3},{12,18.8} ,{14.3,18.8}, {10.6,18.7}, {11,18.9}, {13.5,19.0}]] }
local enemySpawnPoints = {}
local playerGold = 20
local playerPower = 0
local roomsCleared = 0 --Set to 1 for test mode.
local roomsClearedThisFloor = 0
local currentRoom = 0
local currentDungeonFloors = 3 --The max number of "floors" or sections in this dungeon.
local currentFloor = 1
local mapGenSize = 1 --Can be 1-3, larger maps contain more rooms/floors.
local startingDungeonLevel = 1
local currentDungeonLevel = startingDungeonLevel
local difficultyScaleFactor = 0.25

local lastStandActive = false
local campfireActive = false

local questType = "Recruitment" -- Can be "Recruitment, Conquest, Boss, Gather, or Infinite"
local inventory = {nil,nil,nil,nil,nil,nil,nil}

local shopItems = {
Item("Health Potion","Restore 55 Health to a target hero. <color=yellow>Can be used before combat.",1,"icon_enhance_potiondealer_healing_potion",3),
Item("Bomb Brew","Deal 35 damage to all enemies in a target area.",1,"icon_enhance_scorcher_living_bomb",5),
Item("Stun Potion","Stun all enemies in a target area for 4 seconds.",1,"icon_enhance_sunsanctum_sunlight",5),
Item("Stealth Potion","Give a friendly hero Stealth for 5 seconds.",1,"icon_ingame_towerslot_potiondealer",3),
Item("Refresh Potion","Give a friendly hero to instantly refresh a hero's ability.",1,"chronoPotion",3),
Item("Poison Potion","Apply 1 stack of Poison to up to 5 enemies in a target area.",1,"icon_spell_thunder_wave",3),
Item("Mobility Potion","Give a friendly hero the Mobile trait for the rest of this battle.",1,"icon_enhance_frosttower_tempestaura",3),
Item("Omnistone","Gain 2-4 free perks depending on the floor the stone is used on. Grants +30 Gold if saved until the end of the dungeon.",1,"item_omnistone",3,
    {treasureItem = true, hasTarget = false}
),
--[[Item("Room Key","Unlocks a locked room in this dungeon.",1,"dungeonKey",3,{hasTarget = false}),]]
Item("Seer's Eye","Reveal all hidden rooms in your current area.",1,"item_seerseye",3,{treasureItem = true, hasTarget = false}),

}
local recentlyPurchasedItems = {}
local shopItemsToShow = {}

local displayBehaviors = {
    DisplayBehavior("Mobile","icon_spell_barrel_rocket","This unit can be ordered to move during combat."),
    DisplayBehavior("Poison","icon_spell_thunder_wave","This unit is taking Nature damage every second.", true),
    DisplayBehavior("Bleed","icon_enhance_flamecannon_furnace","This unit is taking bleed damage every second, and cannot heal.", true),
    DisplayBehavior("Spellshield","icon_spellshield","This unit is immune to disables and area-of-effect damage."),
    DisplayBehavior("Regrowth Healing","icon_ingame_towerslot_druidtower","This unit is healing over time, and is immune to poison and bleed effects."),
    DisplayBehavior("Taunt","icon_ingame_towerslot_stoneguard","Forces nearby enemies to attack this unit periodically."),
    DisplayBehavior("Immune","icon_spell_shield","This unit is immune to all damage and effects."),
}




local levelsWithoutPerk = 0
--GamePerk(perkName, perkDesc, perkImage, applyBehavior, canStack  ,requiredDungeonLevel)
local gamePerks = {
GamePerk("Barterer","Items in the shop are discounted by 10%.","icon_coin00",false,true),
GamePerk("Inspired Call","At the start of combat, all legionnaires spawn a footman.","icon_ingame_towerslot_crusader"),
GamePerk("Light's Boon","While Priests have their active ability ready, they heal themselves for 2 life per second.","icon_ingame_towerslot_lighthouse",true,false,7),
GamePerk("Improved Weapons","All friendly units deal 8% more damage.","icon_enhance_barracks_dualwield",true,true,10),
GamePerk("Improved Armor","All friendly units take 8% less damage.","icon_enhance_barracks_secondwind",true,true,10),
GamePerk("Steadfast","Your melee units cannot be stunned, and heal for 60 health at the start of every combat.","icon_spell_holy_avengers",true, false ,5),
GamePerk("Stealth Archers","At the start of combat, all Archers become stealthed for 4 seconds.","stealthEye",true,false,7),
GamePerk("Team Discipline","Each party member gains +20% health if your party contains no duplicates of that class.","partyDiscipline",true,false,7),
GamePerk("Scavenging","Gain 30 gold and a random consumable item.","relicScavenging",true,true),
GamePerk("Last Stand","For the next battle only, all party members deal 50% more damage.","icon_enhance_huntershut_watchful_eye",true,true,7),
GamePerk("Campfire","Heal all party members for 40 health.","icon_spell_fire_trap",true,true,5),
GamePerk("Giantslayer","Your heroes deal 10% more damage during Elite fights.","icon_ingame_towerslot_repeater",true,true,8),
GamePerk("Resurrect","Resurrect a random hero that died this run.","icon_enhance_lighthouse_healingword",true,true,12),
GamePerk("Grit","Your Berserkers and Riflemen are now considered Armored, and take 30% less damage.","icon_enhance_stoneguard_stoneskin",true,false),
GamePerk("Powercharged","When your heroes have their active abilities ready, they move and attack 15% faster.","icon_enhance_crusader_punish",true,false),
GamePerk("Quickness","All friendly heroes move 30% faster.","icon_enhance_druidtower_wilds_shape",true,false,7),
GamePerk("Absolute Focus","Your undamaged heroes deal 50% more damage.","focus",true,false),
GamePerk("Persistence","Your heroes regenerate 1 health per second.","persistence",true,false),
GamePerk("Fiery Focus","Reduces the cooldown of the Pyromancer ability by 20%.","icon_ingame_towerslot_scorcher",true,8)}

local forcedPerkOffering = nil
local playerPerks = {} --Table w/ Perks the player has currently.
local map = {}
local roomDifficulty = {}
local clearedRooms = {}
local exploredRooms = {}
local distanceFromRoomToStart = {}
local isEncounterActive = false

local roomTypes = {} --The index of this table will be the room ID.
local specialRoomModifiers = {}

--Affinity(affinityName, affinityPassiveText,affinityIcon, affinityRequiredBonusCount, affinityBonusText, requireExactCount, hasDedicatedBehavior )
local AFFINITIES = { 
    Affinity("Naturalist","Naturalists deal extra damage to Aqua units, but take additional damage from Pyro units.","affinityNaturalist",3,"At the start of combat, spawn an Armored golem to fight alongside you.",false,false),
    Affinity("Pyro","Pyro units deal extra damage to Naturalists, but take additional damage from Aqua units.","affinityPyro",3,"All fire damage is increased by 40%."),
    Affinity("Aqua","Aqua units deal extra damage to Pyro units, but take additional damage from Naturalist units.","affinityAqua",3,"All water damage is increased by 40%."),
    Affinity("Armored","Armored units take 30% less damage from all sources.","affinityArmored",3,"Your Armored heroes gain a permanent Spellshield. Additionally, your Armored units gain 1 Block every 6 seconds."),
    Affinity("Spellcaster","Spellcasters start with their abilities ready and their abilities recharge 25% faster.","affinitySpellcaster",3,"Spellcasters cast and recharge abilities twice as fast."),
    Affinity("Brawler","Brawlers move and attack 15% faster.","affinityBrawler",3,"All Brawlers start combat with 7 Block, and their movement and attack speed bonuses are doubled."),
    Affinity("Holy","Holy units deal 25% bonus damage to Undead units.","affinityHoly",3,"All Holy units restore 2 health per second while their ability is on cooldown."),
    Affinity("Trickster","Tricksters deal +50% damage while stealthed.","affinityTrickster",1,"Your Trickster becomes permanently Stealthed as long as there are at least 3 heroes on the field.",true),
    Affinity("Ranger","Rangers have unlimited attack range.","affinityRanger",2,"Your Ranger's attacks apply 1 stack of Poison.",true),
    Affinity("Specialist","All Specialists gain the Mobile trait, and can be ordered to move during combat.","affinitySpecialist",2,"Units adjacent to a Specialist at the start of combat also become Mobile."),
    
    
    Affinity("Bonus","For each Affinity bonus you have, your team gains +20% damage dealt.","affinityBonus",0,"",false),
    Affinity("Nightmare","Each time you encounter a Nightmare boss, all future Nightmare enemies gain +20% damage dealt.","affinityNightmare",1,"",false),
}

local affinityTokens = {} --Stores a list of affinity (Strings) that count toward affinity bonuses without the player needing to have a hero of that type
local images = {"item_tome","item_tome2","item_tome3"}
for index=1,(GetTableSize(AFFINITIES)-2) do
   table.insert(shopItems,Item("Affinity Tome: "..AFFINITIES[index].name,"Gain a +1 "..AFFINITIES[index].name.." Affinity bonus.",1,images[(index % 3)+1],3,{treasureItem = true, hasTarget = false})) 
end



local inventoryDialog = nil
local inventoryButton = {nil, nil, nil, nil, nil, nil, nil , nil}
local inventoryChargeText = {nil, nil, nil, nil, nil, nil, nil , nil}
local inventoryDiscardButton = {nil, nil, nil, nil, nil, nil, nil , nil}


local enemiesRemaining = 0 --The number of enemy units currently alive (and waiting to die)
local ENEMY_TYPES = {EnemyType("Dorgarian Mercenary",3,"Melee attacker."),
EnemyType("Dorgarian Mercenary",3,"Melee attacker."),
EnemyType("Dorgarian Ranger",3,"Ranged attacker. Deals triple damage to non-armored units."),
 EnemyType("Malevolent Ooze",7,"Can duplicate itself."),
 EnemyType("Witch",5,"Elite ranged attacker - Casts an ability which deals damage to all heroes."),
 EnemyType("Warthog",6,"High-damage melee unit. At the start of combat, charges to the furthest enemy and stuns them for 4 seconds."),
 EnemyType("Nightmare Abomination",25,"A Nightmare Abomination.", {nightmare = true}),
}

 local HERO_TYPES = {
    HeroType("Legionnaire","None.","Spawn a footmen to fight alongside you.","icon_ingame_towerslot_dragoonbarracks"),
    --HeroType("Priest","None,","Heal a target friendly unit.","icon_spell_holy_nova"),
    --HeroType("Assassin","At the start of combat, the Assassin teleports to the furthest 2 enemies and deals 35 damage to them.","The Assassin becomes stealthed for 6 seconds and gains +50% damage dealt, and -50% movement speed.","icon_ingame_hero_lava_chef"),
    --HeroType("Alchemist","While at full health, the Alchemist always generates Team XP and her ability recharges twice as fast.","Channel for 2 seconds and brew a random potion.","icon_ingame_hero_crazy_alchemsit"),
    HeroType("Rifleman","The Rifleman's attacks deal large bonus damage to armored targets.","Deal moderate damage to all targets in front of the Rifleman, and stun them temporarily.","icon_ingame_towerslot_huntershut"),
    HeroType("Berserker","When low on health, the Berserker gains 50% attack speed, and takes 50% less damage.","The Berserker gains a large shield and increases his attack speed.","icon_enhance_flamecannon_furnace"),
    HeroType("Archer","Enemies hit by the Archer take additional damage from all sources. (Stacks up to 8 times).","Fire an arrow in a target direction which deals heavy damage to the first target hit. (Bonus damage to structures).","icon_ingame_towerslot_arrowtower"),
    --HeroType("Druid","The Druid and any allies affected by Regrowth are immune to poison and bleed.","Regrowth: Heal a target for 48 over 8 seconds. While healing, the target takes 25% reduced damage.","icon_ingame_towerslot_druidtower"),
    HeroType("Pyromancer","The Pyromancer's attacks mark a target. If a marked target dies, it explodes and deals damage to all nearby enemies.","Ignite a target location. Enemies at that location take continuous damage over time.","icon_spell_fireball"),
    --HeroType("Knight","The Knight's attacks have a 20% chance to stun its targets for 1 second.","Nearby units gain +3 Block and 40% attack speed for 8 seconds.","icon_ingame_hero_last_dragoon"),
    HeroType("Protector","The Protector has Taunt, and periodically forces nearby enemies to attack her.","Leap to a target location; nearby allies become Immune for 2 seconds, and the Protector gains a large shield for 10 seconds.","icon_ingame_hero_wind_knight"),

}
local partyCurses = {} -- List of debuffs (Behavior names) that will be applied to all party units when a battle begins.
local forcedHeroChoice = nil--HERO_TYPES[11]
local repositionModeActive = false
local selectedUnit = nil
local ITEM_CASTER = DCEI.FindUnit("Item Caster Dummy")
local BUTTON_COUNT = 7 --How many inventory slots there are.
local MANA_COST = 10 --All heroic abilities on player-controlled units have the same mana cost.

local eliteFight = false
local recentElitesKilled = 0
local doublePower = false
local hexGrid = {}
local occupiedHexs = {}
local willBeAmbushed = false
local threatLevel = 0 --(Can be 0-200, represents a %.)
math.randomseed( os.time() )
--MapEvent(eventName, eventDesc, eventChoice1, eventChoice1Desc,eventChoice1Callback, eventChoice2, eventChoice2Desc,eventChoice2Callback, eventChoice3, eventChoice3Desc,eventChoice3Callback)
local gameEvents = {
    MapEvent("Trail of Blood","Your party comes across a trail of blood. What would you like to do?","Explore the Path","[Starts a Battle. If you win, you will be able to recruit a hero.]",
        function()
            local willBeElite = RandomChance(threatLevel - 40)
            GenerateEncounter(currentDungeonLevel, nil, willBeElite)
            ToggleMapFrame(false)
            CreateCombatDialog()
            earnsHeroThisLevel = true
        end,
        "Ignore the Path",
        "Continue adventuring and ignore the path.",
        DoNothing
    ),

    MapEvent("Strange Caravan","Your party comes across a caravan of travelers from all origins. What would you like to do?","Trade","[Shop for items.]",
        function()
            CreateShopDialog()
        end,
        "Train with them",
        "[Gain a free perk.]",
        function()
            GiveFreePerk()
        end,
        "Ask for Directions",
        "[Reveals all hidden rooms.]",
        function()
            ExecuteCampsiteDecision(3)
        end
    ),

    MapEvent("Wayward Shrine","Your party comes across a shrine. What do you do?","Honor it","[Gain 1 random Affinity bonus.]",
        function()
            AddRandomAffinityBonus()
        end, "Destroy it", "[Gain 2 random Affinity bonuses. Generates +50% Threat.]",
        function()
            AddRandomAffinityBonus()
            DCEI.Wait(1)
            AddRandomAffinityBonus()
            DCEI.Wait(1)
            IncreasePlayerThreat(50)
        end,"Loot it","[Gain 50 gold and a consumable item. Generates 15% Threat.]",
        function()
            playerGold = playerGold + 50
            ClaimItem(GetRandomElement(shopItems))
            UpdateGoldPanel()
            IncreasePlayerThreat(15)
        end
    ),

    MapEvent("Brave Warrior","Your party comes across a brave warrior; perhaps if you can prove your courage, he will join you.","Let out a warcry","[Recruit a Brawler hero. Generates +35% Threat.]",
        function()
            local berserker = HERO_TYPES[6]
            local affin1 = berserker.affinities[1].name
            DCEI.LogMessage("Got Brawler hero 1st affin: "..affin1)
            local brawlers = GetRandomHeroesWithAffinity("Brawler")
            DCEI.LogMessage("Presenting Brawler hero choice with count: "..GetTableSize(brawlers))
            PresentHeroChoice(brawlers, function()
                IncreasePlayerThreat(35)
            end)
        end, "Hire the Warrior", "[Recruit a random Brawler hero. Pay 50 gold.]",
        function()
            PresentHeroChoice(GetRandomHeroesWithAffinity("Brawler"), function()
                playerGold = playerGold - 50
            end)
        end,"Train with the Warrior","[Gain a free perk.]",
        function()
            GiveFreePerk()
        end
    ),

    MapEvent("Dark Chalice","Your party finds a dark chalice. What should be done with it?","Drink from it","[Chance to receive a Curse or 2 Perks at random.]",
        function()
            local cursePlayer = RandomChance(40)
            if(cursePlayer) then
                ShowRelevantText("<color=purple>CURSED!")
                DCEI.Wait(1)
                table.insert(partyCurses,"Cursed")
                
            else
                ShowRelevantText("<color=green>+2 Perks!")
                DCEI.Wait(1)
                GiveFreePerk(2)
                DCEI.Wait(1)
                
            end
        end, "Destroy the Chalice", "[Gain a +1 Holy Affinity bonus. Generates +20% Threat.]",
        function()
            AddAffinityBonus("Holy")
            DCEI.Wait(1)
            IncreasePlayerThreat(20)
            DCEI.Wait(1)
        end
    ),

    MapEvent("Vial of Holy Water","Your party finds a vial of holy water. What should be done with it?","Consecrate it","[Gain a +1 Holy Affinity bonus.]",
        function()
            AddAffinityBonus("Holy")
            DCEI.Wait(1)
        end, "Drink it", "[All party members are healed to full health.]",
        function()
            for index=1,PARTY_SIZE do
                if(partyUnitHealth[index] ~= nil and partyUnitHealth[index] >= 1) then
                    local heroToRevive = partyUnits[index]
                    partyUnitHealth[index] = DCEI.UnitTypeHealth(partyUnits[index])
                end
            end
            ShowRelevantText("<color=green>All party members healed!")
            DCEI.Wait(1)
        end, "Resurrection Ritual", "[All fallen party members are resurrected to full health.]",
        function()
            for index=1,PARTY_SIZE do
                if(partyUnitHealth[index] ~= nil and partyUnitHealth[index] <= 0) then
                    local heroToRevive = partyUnits[index]
                    partyUnitHealth[index] = DCEI.UnitTypeHealth(partyUnits[index])
                end
            end
        end
    ),

    MapEvent("Shallow Gravesite","Your party comes across a shallow, unholy gravesite. What should you do?","Excavate the site","[Starts an Elite encounter.]",
        function()
            
            GenerateEncounter(currentDungeonLevel + 12, nil, true)
            ToggleMapFrame(false)
            CreateCombatDialog()
            
        end, "Walk through the site", "[Generates +10% Threat.]",
        function()
            IncreasePlayerThreat(10)
            DCEI.Wait(1)
        end
    ),

    MapEvent("Hostile Screeching","Your party hears noises coming from not-so-distant creatures. What should you do?","Proceed as normal","[Starts a combat.]",
        function()
            
            GenerateEncounter(currentDungeonLevel + 5, nil)
            ToggleMapFrame(false)
            CreateCombatDialog()
            
        end, "Cover your Tracks", "[Reduce Threat by 20%.]",
        function()
            DecreasePlayerThreat(20)
            DCEI.Wait(1)
        end
    ),

}

local testEventID = 8
local displayedEvents = {}
-- TRIGGERS


--Sets map size, difficulty scaling, etc based on the given difficulty parameter at game start.
function InitializeMapGenSettings()
    local mode = dungeonData.type
    local maxFloors = 3
    if(mode == "Conquest") then
        maxFloors = 4
    end
    currentDungeonFloors = 2
    startingDungeonLevel = 1
    currentDungeonLevel = startingDungeonLevel
    mapGenSize = 2
    difficultyScaleFactor = 0.15
    difficultyScaleFactor = Clamp(difficultyScaleFactor,0.20,2)
end
DCEI.SetTooltipBackgroundImage("frame_dark_stroke")
InitializeMapGenSettings()
function SetDefaultSpawns()
    for index = 1, GetTableSize(hexGrid) do
        defaultSpawns[index] = {}
        defaultSpawns[index].x = hexGrid[index].point.x + snapOffset.x
        defaultSpawns[index].y = hexGrid[index].point.y + snapOffset.y
    end
    local spawnPoints = DCEI.FindUnitsAsCollection("Point_Marker")
    local pointCount = DCEI.GetCollectionSize(spawnPoints)
    --DCEI.LogMessage("Registered spawn point COUNT "..pointCount)
    for index = 1, pointCount do
        local unit = DCEI.GetCollectionItem(spawnPoints,index)
        local point = DCEI.GetUnitPosition2D(unit)
        --DCEI.LogMessage("Registered spawn point: "..point.x.." , "..point.y)
        table.insert(enemySpawnPoints,point)
        DCEI.RemoveUnit(unit)
    end
end

function round(num, numDecimalPlaces)
    local mult = 10^(numDecimalPlaces or 0)
    return math.floor(num * mult + 0.5) / mult
  end

function PartyHasHero(heroType)
    --DCEI.LogMessage("Checking for unit type in party:"..heroType.name)
    for index=1,PARTY_SIZE do
        local pUnit = partyUnits[index]
        --DCEI.LogMessage("      ["..(index).."] Recognized unit type in party:"..pUnit)
        if(pUnit == heroType.name) then
            return true
        end
    end
    return false
end

function GetRandomAffinity()
    local randomIndex = GetRandomNumber(1,GetTableSize(AFFINITIES)-2)--Subtract 2 for the "bonus" and "Nightmare" affinities, which aren't real bonuses.
    return AFFINITIES[randomIndex]
end

function GetRandomAffinityTome()
    local tomeName = "Affinity Tome: "..GetRandomAffinity().name
    return tomeName
end

function AddRandomAffinityBonus()
    local affinity = GetRandomAffinity()
    ShowRelevantText("+ "..affinity.name.." Bonus")
    table.insert(affinityTokens,affinity.name)
    UpdateActiveAffinities()
end

function AddAffinityBonus(affinityName)
    local affinity = GetAffinityByName(affinityName)
    ShowRelevantText("+ "..affinity.name.." Bonus")
    table.insert(affinityTokens,affinity.name)
    UpdateActiveAffinities()
end
  
function GetAdjacentHeroUnits(sourceUnit)
    local returnList = {}
    if(party == nil) then
        DCEI.LogMessage("WARNING - Party object is nil!")
    end
    DCEI.LogMessage("Got Party size: "..GetTableSize(party))
    for index=1,PARTY_SIZE do
        local unit = party[index]
        if(UnitIsAlive(unit) and GetSquaredDistanceBetweenPoints({x = DCEI.GetUnitPosition2D(sourceUnit).x, y= DCEI.GetUnitPosition2D(sourceUnit).y+0.35}, DCEI.GetUnitPosition2D(unit) ) <= 2.25 and unit ~= sourceUnit) then
            table.insert(returnList, unit)
        end
    end
    
    return returnList
end


function RegisterHexs()
    local sourceHex = DCEI.CreateUnit(1,1,"Point_Marker Alpha",13.53,18.8)
    --CreateHexUnit(sourceHex)
    local targetPos = GetHexCoordsFromSource(sourceHex,"Left",1)
    local hex = nil

    

    
   
    --CreateHexUnit(hex)
    --targetPos = GetHexCoordsFromSource(sourceHex,"Up-Right",1)
    --hex = DCEI.CreateUnit(1,1,"Point_Marker Alpha",targetPos.x,targetPos.y)
    --CreateHexUnit(hex)
    --targetPos = GetHexCoordsFromSource(sourceHex,"Up-Left",1)
    --hex = DCEI.CreateUnit(1,1,"Point_Marker Alpha",targetPos.x,targetPos.y)
    --CreateHexUnit(hex)
    local ROW_ONE_COUNT = 4
    for index=1,ROW_ONE_COUNT do
        targetPos = GetHexCoordsFromSource(sourceHex,"Left",index)
        hex = DCEI.CreateUnit(1,1,"Point_Marker Alpha",targetPos.x,targetPos.y)
        --CreateHexUnit(hex)
        --targetPos = GetHexCoordsFromSource(hex,"Up-Right",1)
        --hex = DCEI.CreateUnit(1,1,"Point_Marker Alpha",targetPos.x,targetPos.y)
        --CreateHexUnit(hex)
    end

    targetPos = GetHexCoordsFromSource(sourceHex,"Right",1)
    hex = DCEI.CreateUnit(1,1,"Point_Marker Alpha",targetPos.x,targetPos.y)
    
    
    local hexPoints = DCEI.FindUnitsAsCollection("Point_Marker Alpha")
    local pointCount = DCEI.GetCollectionSize(hexPoints)
    --DCEI.LogMessage("Registered hex point COUNT "..pointCount)
    for index = 1, pointCount do
        local unit = DCEI.GetCollectionItem(hexPoints,index)
        local point = DCEI.GetUnitPosition2D(unit)
        hexGrid[index] = {}
        hexGrid[index].unit = unit
        hexGrid[index].point = point
        CreateHexUnit(unit,index)
    end

end

function GetClosestHexPointToPoint(sourcePoint, requireUnoccupied)
    local shortestDistance = 20000
    local shortestPoint = nil
    local shortestPointIndex = 0
    for index=1,21 do
        local distance = GetSquaredDistanceBetweenPoints(hexGrid[index].point , sourcePoint)
        if(distance <= shortestDistance and (TableContains(occupiedHexs,index) == false or requireUnoccupied == nil or requireUnoccupied == false)) then
            shortestDistance = distance
            shortestPoint = hexGrid[index]
            shortestPointIndex = index
        end
        
    end
    if(requireUnoccupied ~= nil and requireUnoccupied == true) then
        --table.insert(occupiedHexs,shortestPointIndex)
    end
    
    return shortestPoint.point

end

function GetClosestHexIndexToPoint(sourcePoint)
    local shortestDistance = 20000
    local shortestPoint = nil
    local shortestPointIndex = 0
    for index=1,21 do
        local distance = GetSquaredDistanceBetweenPoints(hexGrid[index].point , sourcePoint)
        if(distance <= shortestDistance) then
            shortestDistance = distance
            shortestPoint = hexGrid[index]
            shortestPointIndex = index
        end
        
    end
    return shortestPointIndex
end

function SetOccupiedHexPoints(excludedPointIndex)
    --DCEI.LogMessage("SetOccupiedHexPoint() called!")
    occupiedHexs = {}
    for index=1,PARTY_SIZE do
        local isAlive = (partyUnitHealth[index] == nil or partyUnitHealth[index] > 0)
        if(isAlive == false) then
            --DCEI.LogMessage("Party unit ID: "..index.." is not alive! Will not set an occupied hex for them.")
        end
        
        if(isAlive and partyUnitPosition[index] ~= nil) then
            local hexIndex = GetClosestHexIndexToPoint(partyUnitPosition[index]) 
            if(excludedPointIndex == nil or hexIndex ~= excludedPointIndex) then
                table.insert(occupiedHexs, hexIndex  )
                --DCEI.LogMessage("Setting HP:"..hexIndex.." as occupied!")
            end
            
        end
    end
    --[[foreach(party, function(partyMember)
        if(partyMember ~= nil and partyMember ~= selectedUnit) then
            table.insert(occupiedHexs, GetClosestHexIndexToPoint(DCEI.GetUnitPosition2D(partyMember))   )
        end
        
    end)]]
    UpdateHexGrid()
end

function GetEmptyHexPoint()
    for index=1,21 do
        if(TableContains(occupiedHexs, index) == false) then
            return hexGrid[index].point
        end
    end
    return 0
end

local SPACING = 1.0
local SPACING_Y_FACTOR = 1.15
local SPACING_X_FACTOR = .46
function GetHexCoordsFromSource(sourceHexUnit,direction,directionSteps)
    local sourcePosition = DCEI.GetUnitPosition2D(sourceHexUnit)
    local changeVector = {x=0, y=0}
    if(direction == "Left") then
        changeVector.x = SPACING * -1
    elseif(direction == "Right") then
        changeVector.x = SPACING
    elseif(direction == "Up-Right") then
        changeVector.x = SPACING - SPACING_X_FACTOR
        changeVector.y = SPACING * SPACING_Y_FACTOR
    elseif(direction == "Up-Left") then
        changeVector.x = SPACING * -1 * SPACING_X_FACTOR
        changeVector.y = SPACING * SPACING_Y_FACTOR
    elseif(direction == "Down-Right") then
        changeVector.x = SPACING * SPACING_X_FACTOR
        changeVector.y = SPACING * SPACING_Y_FACTOR * -1
    elseif(direction == "Down-Left") then
        changeVector.x = SPACING * SPACING_X_FACTOR * -1
        changeVector.y = SPACING * SPACING_Y_FACTOR * -1
    end
    local returnPosition = {x = sourcePosition.x + (directionSteps * changeVector.x), y = sourcePosition.y + (directionSteps * changeVector.y) }
    --DCEI.LogMessage("Got GHXC Pos: "..(returnPosition.x)..","..returnPosition.y)
    return returnPosition
end

-- HELPER FUNCTIONS

function PlaySound(soundName)
    DCEI.CreateEffect(soundName,ITEM_CASTER,12,22)
end

--[[ 
    X & Y PARAMATERS
        denote horizontal & vertical offset
    
    OPTIONS PARAMETERS
        options.parent          -   creates the bighand inside the specified UI frame (otherwise UI root is used)
        options.anchor_left     -   anchors the bighand to the left
        options.anchor_right    -   anchors the bighand to the right
        options.anchor_top      -   anchors the bighand to the top
        options.anchor_bottom   -   anchors the bighand to the bottom
        options.unit            -   attaches the bighand to the specified unit
        options.flip            -   if true, flips the bighand horizontally
--]]


function NewBigHand(x, y, options)
    x, y = x or 0, y or 0
    local scale = options and options.scale or 1
    local helper = {}
    local bounce_start = 0
    local bounce_end = 25 * scale
    local bounce_x = bounce_end
    local bounce_y = bounce_end

    local parent = options and options.parent or DCEI.GetUiRoot()

    local anchor = DCEI.NewFrame(parent)
    helper.anchor = anchor

    local frame = DCEI.NewFrame(anchor)
    DCEI.SetVerticalOffsetInParent(frame, y)
    DCEI.SetHorizontalOffsetInParent(frame, x)
    DCEI.SetBackgroundImage(frame, "pointy_finger")
    DCEI.SetSize(frame, 108 * scale, 87 * scale)

    if options then
        if options.anchor_left then
            DCEI.SetLeftAlignmentInParent(anchor)
        end
        if options.anchor_right then
            DCEI.SetRightAlignmentInParent(anchor)
        end
        if options.anchor_top then
            DCEI.SetTopAlignmentInParent(anchor)
        end
        if options.anchor_bottom then
            DCEI.SetBottomAlignmentInParent(anchor)
        end
        if options.flip then
            DCEI.SetRotation3D(frame, 0, 180, 0)
            bounce_x = -1 * bounce_x
        end
        if options.unit then
            local attach = options.attach or {}
            DCEI.AttachToUnit(anchor, options.unit, attach)
        end
    end

    local function BounceDown()
        local duration = 0.5
        local ease = "InQuad"

        DCEI.AnimateVerticalOffset(frame, y + bounce_y, y + bounce_start, duration, ease)
        DCEI.AnimateHorizontalOffset(frame, x + bounce_x, x + bounce_start, duration, ease)

        if helper then
            DCEI.TriggerAddTimerEventElapsed(helper.BounceUp, duration + 0.0625, true)
        end
    end
    local function BounceUp()
        local duration = 0.5
        local ease = "OutQuad"

        DCEI.AnimateVerticalOffset(frame, y + bounce_start, y + bounce_y, duration, ease)
        DCEI.AnimateHorizontalOffset(frame, x + bounce_start, x + bounce_x, duration, ease)

        if helper then
            DCEI.TriggerAddTimerEventElapsed(helper.BounceDown, duration + 0.0625, true)
        end
    end

    function helper.Destroy()
        -- store temp frame reference so parent table can be destroyed
        local temp = helper.anchor
        helper = nil

        -- hide the pointer frame and destroy it later
        DCEI.SetActive(temp, false)

        DCEI.TriggerAddTimerEventElapsed(
            function()
                DCEI.Destroy(temp)
            end,
            0.625
        )
    end

    helper.BounceUp = BounceUp
    helper.BounceDown = BounceDown
    BounceUp()
    return helper
end

function HealUnit(unit, amount, healText)
    DCEI.AddHealth(unit,amount)
    if(healText ~= nil) then 
        local options = { 
            offset = {
                up = 1.05,
                right = 0,
                front = 0
            }
        }
        DCEI.ShowFloatingText(DCEI.GetUnitPosition3D(unit),"<size=12><color=green>"..healText,1.7,0,1,options )
    end
    
end

function OnEliteDeath(context)
    local options = { 
        offset = {
            up = 1.05,
            right = 0,
            front = 0
        }
    }
    
    local goldBonus = 15 + (GetRandomNumber(7,15) * (recentElitesKilled+1)) + (GetRandomNumber(4,11)*currentFloor)
    DCEI.ShowFloatingText(DCEI.GetUnitPosition3D(context.source),"<size=14><color=yellow>+ "..(goldBonus).." Gold",2,0,1,options )
    recentElitesKilled = recentElitesKilled + 1
    
    playerGold = playerGold + goldBonus
    UpdateGoldPanel()
end

function ShowSpeechBubble(speechUnit, width, message, duration)
    DCEI.ShowSpeechBubble(speechUnit,width,message,DCEI.UnitType(speechUnit))
    DCEI.Wait(duration)
    DCEI.HideSpeechBubble(speechUnit)
end

function GetRandomPartyMember()
    local possibleList = {}

    foreach(party, function(unit)
        if(unit ~= nil and UnitIsAlive(unit)) then
            table.insert(possibleList,unit)
        end
    end)
    return GetRandomElement(possibleList)
end

function GetRandomHeroPosition()
    return DCEI.GetUnitPosition2D(GetRandomPartyMember())
end

function UnitIsAlive(unit) 
    if(unit == nil) then return false end
    return DCEI.GetHealthValue(unit) >= 1
end

function UnitIsMelee(unit)
    return DCEI.UnitBehaviorStackCount(unit, "Melee") >= 1
end

function UnitIsRanged(unit)
    return DCEI.UnitBehaviorStackCount(unit, "Ranged") >= 1
end

function GetUnitDescription(unitLink)
    local returnDesc = "???"
    if(IsHeroUnit(unitLink)) then
        
        foreach(HERO_TYPES,function(hero)
            --DCEI.LogMessage("Comparing selected unit: "..DCEI.UnitName(unitLink).." to known hero: "..hero.name)
            if(hero.name == DCEI.UnitName(unitLink)) then
                --DCEI.LogMessage("Got hero name match!")
                returnDesc = hero.name
            end
        end)
    else
        foreach(ENEMY_TYPES, function(enemy)
            --DCEI.LogMessage("Comparing selected unit: "..DCEI.UnitName(unitLink).." to known enemy: "..enemy.name)
            if(enemy.name == DCEI.UnitName(unitLink)) then
                --DCEI.LogMessage("Got enemy name match!")
                returnDesc = enemy.description
            end
        end)
    end
    return returnDesc
end

function TableContains(table, element)
    if(table == nil) then 
        return false 
    end
    for index = 1, GetTableSize(table) do
        if(table[index] == element) then return true end
    end
    return false
end

function RemoveDuplicates(sourceTable)
    local returnTable = {}
    foreach(sourceTable, function(value)
        if(TableContains(returnTable,value) == false) then
            table.insert(returnTable,value)
        end
    
    end)
    return returnTable
end

function table.clone(org)
    return {table.unpack(org)}
  end

function ShuffleTable(T)
    shuffled = {}
    for i, v in ipairs(T) do
	    local pos = math.random(1, #shuffled+1)
	    table.insert(shuffled, pos, v)
    end
    return shuffled
end


  function GetRandomNumber(min, max)
    return math.random(min,max)
  end

  function GetRandomElement(T)
    local randomIndex = math.random(1,GetTableSize(T))
    return T[randomIndex]
  end

  function GetRandomIndex(T)
    local randomIndex = math.random(1,GetTableSize(T))
    return randomIndex
  end

  function IsHeroUnit(unit)
    return unit ~= nil and DCEI.UnitBehaviorStackCount(unit,"Heroic") > 0
  end

  function DoesPartyHaveDuplicatesOf(unitType)
    local returnValue = false
    local countOfType = 0
    foreach(partyUnits, function(unit)
        if(unit == unitType) then
            countOfType = countOfType + 1
        end
    end)
    return countOfType > 1
  end

  function GetRandomAdjacentRoom(roomID)
    local possibleRooms = GetAllPossibleAdjacentRooms(roomID)
    return GetRandomElement(possibleRooms)
end

function DoesRoomExist(roomID)
    return TableContains(map,roomID)
end

function IsWithinRoomBounds(id)
    if(id > 0 and id <= 25) then
        return true
    end
    return false
end

function GetRoomInDirection(sourceRoomID, direction) 
    local modifier = 0
    if(direction == "Left") then
        modifier = -1
    end
    if(direction == "Right") then
        modifier = 1
    end
    if(direction == "Down") then
        modifier = -5
    end
    if(direction == "Up") then
        modifier = 5
    end

    local targetRoomID = sourceRoomID + modifier
    if(IsWithinRoomBounds(targetRoomID) == false) then return nil end
    if(sourceRoomID % 5 == 0 and direction == "Right") then return nil end --These rooms cant have a room to the right of them.
    if(sourceRoomID % 5 == 1 and direction == "Left") then return nil end --These rooms cant have a room to the left of them.
    return targetRoomID
end

function SetRoomType(roomID, type)
    roomTypes[roomID] = type
    --DCEI.LogMessage("Set room ID: "..roomID.." to type: "..type)
    --DCEI.LogMessage("Room ID "..roomID.." is: "..roomTypes[roomID])
end

function GetRoomType(roomID)
    if(roomTypes[roomID] == nil) then
        return "Combat"
    end
    return roomTypes[roomID]
end

function IsRoomExplored(roomID)
    return TableContains(exploredRooms,roomID) or GetRoomType(roomID) == "Nightmare"
end

function GetTotalRoomCount()
    local nonExistentRooms = 0
    for index=1,25 do
        if(DoesRoomExist(index) == false) then
            nonExistentRooms = nonExistentRooms + 1
        end
    end
    return 25-nonExistentRooms
    
end

function GetUnexploredRoomCount()
    local totalRooms = GetTotalRoomCount()
    for index=1,25 do
        if(IsRoomExplored(index) == true) then
            totalRooms = totalRooms - 1
        end
    end
    return totalRooms
end

function GetClearedRoomsPercent()
    local totalRooms = GetTotalRoomCount()
    local visitedRooms = 0
    for index=1,25 do
        if(HasRoomBeenVisited(index) == true) then
            visitedRooms = visitedRooms + 1
        end
    end
    DCEI.LogMessage("Cleared rooms Percent: "..(1+math.ceil((visitedRooms/totalRooms) * 100.0)))
    return 1+math.ceil(((1+visitedRooms)/totalRooms) * 100.0)
end

function GetRoomTypeCount(roomType)
    local roomCount = 0
    for index=1,25 do
        if(GetRoomType(index) == roomType and HasRoomBeenVisited(index) == false) then
            roomCount = roomCount + 1
        end
    end
    return roomCount
end



function HasAdjacentRooms(sourceRoomID, sourceMap)
    if(sourceMap == nil) then sourceMap = map end
    if(TableContains(sourceMap,GetRoomInDirection(sourceRoomID,"Up"))) then return true end
    if(TableContains(sourceMap,GetRoomInDirection(sourceRoomID,"Down"))) then return true end
    if(TableContains(sourceMap,GetRoomInDirection(sourceRoomID,"Left"))) then return true end
    if(TableContains(sourceMap,GetRoomInDirection(sourceRoomID,"Right"))) then return true end
    return false
end

function HasAdjacentRoomOfType(sourceRoomID,searchType, sourceMap)
    if(sourceMap == nil) then sourceMap = map end
    local adjacentRooms = GetAllPossibleAdjacentRooms(sourceRoomID)
    local returnValue = false
    foreach(adjacentRooms, function(room)
        if(TableContains(sourceMap,room)) then
            if(GetRoomType(room) == searchType) then
                --DCEI.LogMessage("Room ID:"..sourceRoomID.." has adjacent room of type: "..searchType.."! Adj_Room="..room)
                returnValue = true
            end
        end
    end)
    return returnValue
end

function GetAdjacentRoomsCount(sourceRoomID, sourceMap)
    if(sourceMap == nil) then sourceMap = map end
    local adjacentRooms = GetAllPossibleAdjacentRooms(sourceRoomID)
    local returnCount = 0
    for index=1,GetTableSize(adjacentRooms) do
        if(TableContains(sourceMap, adjacentRooms[index])) then
            returnCount = returnCount + 1
        end
    end
    return returnCount
end

function GetAllPossibleAdjacentRooms(sourceRoomID)
    local returnRooms = {}
    if(GetRoomInDirection(sourceRoomID,"Up") ~= nil) then
        table.insert(returnRooms, GetRoomInDirection(sourceRoomID,"Up"))
    end
    if(GetRoomInDirection(sourceRoomID,"Down") ~= nil) then
        table.insert(returnRooms, GetRoomInDirection(sourceRoomID,"Down"))
    end
    if(GetRoomInDirection(sourceRoomID,"Left") ~= nil) then
        table.insert(returnRooms, GetRoomInDirection(sourceRoomID,"Left"))
    end
    if(GetRoomInDirection(sourceRoomID,"Right") ~= nil) then
        table.insert(returnRooms, GetRoomInDirection(sourceRoomID,"Right"))
    end
    return returnRooms
end

function GetRoomsOfType(requiredType, minimumRoomID, maxRoomID, forbiddenAdjacentRooms, mapToUse)
    local returnRooms = {}
    foreach(mapToUse, function(roomID)
        if(roomID >= minimumRoomID and roomID <= maxRoomID and GetRoomType(roomID) == requiredType and TableContains(forbiddenAdjacentRooms, roomID) == false) then
            table.insert(returnRooms, roomID)
        end
    end)
    return returnRooms
end

function GetRandomUnaddedRoom(sourceMap)
    if(sourceMap == nil) then sourceMap = map end
    local possibleRooms = {}

    foreach(sourceMap, function(room)
        local adjacent = GetAllPossibleAdjacentRooms(room)
        foreach(adjacent, function(nearRoom)
            if(TableContains(sourceMap,nearRoom) == false) then
                table.insert(possibleRooms,nearRoom)
            end
        end)
    end)

    if(GetTableSize(possibleRooms) <= 1) then
        return nil
    end
    return GetRandomElement(possibleRooms)
end

function ExploreRoom(roomID)
    --DCEI.LogMessage("Attempting to explore room ID:"..roomID)
    if(GetRoomType(roomID) == "Stairs") then
        --DCEI.LogMessage("Could not explore room ID: "..roomID.. " because it is a staircase!")
        return 
    end
    table.insert(exploredRooms,roomID)
    --DCEI.LogMessage("Successfully explored room:"..roomID)
    --local adjRooms = GetAllPossibleAdjacentRooms(roomID)
    --[[for index=1, GetTableSize(adjRooms) do
        --DCEI.LogMessage("Got adjacent room from:"..roomID.." adj:"..index)
        table.insert(exploredRooms,adjRooms[index])
        --DCEI.LogMessage("Explored Adjacent room:"..adjRooms[index])
    end]]
    UpdateMapPanel()
end

function ForceExploreRoom(roomID)
    table.insert(exploredRooms,roomID)

end



function RemoveRoom(roomID, mapTable, starterRoom)
    if(mapTable == nil) then
        mapTable = map
    end
    
    for index=1,25 do
        local room = mapTable[index]
        if(room == roomID) then
            mapTable[index] = starterRoom
        end
    end
end

function IsEdgeRoom(roomID)
    return roomID % 5 == 1 or roomID % 5 == 0 or roomID >= 21 or roomID <= 5
end

function AreRoomsAdjacent(sourceRoom, targetRoom)
    local adjacentRooms = GetAllPossibleAdjacentRooms(sourceRoom)
    return TableContains(adjacentRooms, targetRoom)
end

function GenerateMap(floorID)
    battleOngoing = false
    clearedRooms = {}
    exploredRooms = {}
    map = {}
    roomTypes = {}
    specialRoomModifiers = {}
    timesNightmareUpdated = 0
    roomsClearedThisFloor = 0
    distanceFromRoomToStart = {}
    
    recentlyPurchasedItems = {}
    
    local isTopFloor = floorID == currentDungeonFloors
    local returnList = {}
    local possibleRooms = {}
    if(threatLevel < 100) then
        threatLevel = math.ceil(threatLevel * 0.6)
    else
        threatLevel = math.ceil(threatLevel * 0.75)
    end
    
    
    for index = 1, 25 do
        table.insert(possibleRooms,index)
        specialRoomModifiers[index] = "None"
    end
    local starterRoom = GetRandomNumber(1,5)
    
    local topRoom = GetRandomNumber(21,25)
    if(isTopFloor == false) then
        --SetRoomType(topRoom,"Stairs")
        --DCEI.LogMessage("Room ID 23 is: "..roomTypes[23])
    end
    local centerRoom = GetRandomNumber(11,15)
    local adjacentTopRoom = GetRandomAdjacentRoom(topRoom)
    local adjacentBottom = GetRoomInDirection(adjacentTopRoom,"Down")
    if(adjacentBottom ~= centerRoom and RandomChance(60)) then 
        --SetRoomType(adjacentBottom,"Shop")
    end
   
    local adjacentTop = GetRoomInDirection(starterRoom,"Up")
    
    table.insert(returnList, starterRoom)
    table.insert(returnList, centerRoom)
    table.insert(returnList, topRoom)
    table.insert(returnList, adjacentTopRoom)
    table.insert(returnList, adjacentBottom)
    local adj1 = GetRandomAdjacentRoom(starterRoom)
    table.insert(returnList, adj1)
    table.insert(returnList, GetRandomAdjacentRoom(adj1))
    local forcedShopRoom = GetRandomAdjacentRoom(centerRoom)
    --SetRoomType(forcedShopRoom,"Shop")
    table.insert(returnList, forcedShopRoom)
    table.insert(returnList, GetRandomAdjacentRoom(centerRoom))
    table.insert(returnList, GetRandomAdjacentRoom(GetRandomAdjacentRoom(centerRoom)))
    forcedShopRoom = GetRandomAdjacentRoom(GetRandomAdjacentRoom(adj1))
    if(forcedShopRoom ~= starterRoom and forcedShopRoom ~= centerRoom and isTopFloor == false and RandomChance(60)) then
        --SetRoomType(forcedShopRoom,"Shop")
    end
    table.insert(returnList,forcedShopRoom )
    table.insert(returnList, GetRandomAdjacentRoom(starterRoom))
    for index=1,(2*mapGenSize)+1 do
        local randomRoom = GetRandomNumber(6,25)
        table.insert(returnList, randomRoom)
        if(RandomChance(((floorID)*14)-16) and randomRoom > 10) then
            --SetRoomType(randomRoom,"Elite")
        end
    end

    for index=1,(floorID+1) do
        local randomRoom = GetRandomNumber(16,20)
        table.insert(returnList, randomRoom)
        if((RandomChance(1+(floorID*4)) and randomRoom > 10) or (IsEdgeRoom(randomRoom) and RandomChance(floorID*17))) then
            --SetRoomType(randomRoom,"Elite")
        elseif (RandomChance(15-(floorID*2))) then
            --SetRoomType(randomRoom,"Shop")
        end
    end

    --[[for index=1,7 do
        local randomRoom = GetRandomNumber(6,15)
        table.insert(returnList, randomRoom)
        if(RandomChance(2+(floorID*2))) then
            SetRoomType(randomRoom,"Elite")
        elseif (RandomChance(20)) then
            SetRoomType(randomRoom,"Shop")
        elseif (RandomChance(5)) then
            SetRoomType(randomRoom,"Treasure")
        end
    end]]
    local attemptNum = 1
    while(ArePointsConnected(starterRoom,topRoom,returnList) == false) do
        --DCEI.LogMessage("Start and end rooms not connected. Attempt: "..attemptNum)
        local unconnectedRooms = {}

        for index = 1, GetTableSize(returnList) do
            if(HasAdjacentRooms(returnList[index],returnList) == false) then
                local randomRoom = GetRandomAdjacentRoom(returnList[index])
                table.insert(returnList,randomRoom)
                if(RandomChance(10-floorID) == true) then
                    --SetRoomType(randomRoom,"Shop")
                elseif(RandomChance(6 + floorID) == true) then
                    --SetRoomType(randomRoom,"Treasure")
                end

            end
        end
        
        if(RandomChance(mapGenSize*10)) then
            local roomToAdd = GetRandomUnaddedRoom(returnList)
            for index = 1, 2 do
                table.insert(returnList, roomToAdd)
            end
            roomToAdd = GetRandomUnaddedRoom(returnList)
            for index = 1, 2 do
                local randomRoom = GetRandomNumber(1,20)
                table.insert(returnList, roomToAdd)
            end
        end
        

        attemptNum = attemptNum + 1
    end

    local attempts = 0
    if(ArePointsConnected(starterRoom,topRoom,returnList,0) == false) then
        --DCEI.LogMessage("Start and end rooms not connected. Attempt: "..1)
        local unconnectedRooms = {}

        for index = 1, GetTableSize(returnList) do
            if(HasAdjacentRooms(returnList[index],returnList) == false) then
                local randomRoom = GetRandomAdjacentRoom(returnList[index])
                table.insert(returnList,randomRoom)
                if(RandomChance(8 - floorID) == true) then
                    --SetRoomType(randomRoom,"Shop")
                elseif(RandomChance(6 + floorID) == true) then
                    --SetRoomType(randomRoom,"Treasure")
                end

            end
        end
        for index = 1, mapGenSize do
            table.insert(returnList, GetRandomNumber(6,20))
        end
        attempts = attempts + 1
    end


    

    --[[if(ArePointsConnected(starterRoom,topRoom,returnList,0) == false) then
        DCEI.LogMessage("Start and end rooms not connected. Attempt: "..2)
        for index = 1, 4 do
            local randomRoom = GetRandomNumber(1,20)
            table.insert(returnList, randomRoom)
        end
    end
    if(ArePointsConnected(starterRoom,topRoom,returnList,0) == false) then
       DCEI.LogMessage("Start and end rooms not connected. Attempt: "..3)
        for index = 1, 2 do
            table.insert(returnList, GetRandomNumber(6,20))
        end
    end

    

    if(ArePointsConnected(starterRoom,topRoom,returnList,0) == false) then
        DCEI.LogMessage("Start and end rooms not connected. Attempt: "..4)
        for index = 1, 2 do
            table.insert(returnList, GetRandomNumber(6,20))
        end
    end]]

    


    --Tutorial map gen

    if(floorID == 1) then
        returnList = { 1,2,3,8,7,12,13,14,19,20,24,25}
    else
        returnList = { 5,4,9,8,3,13,12,11}
    end
    


    
    table.sort(returnList, function(a, b) return a < b end)

    foreach(returnList, function(roomID)
        SetRoomType(roomID, "Combat")
    end)

    if(floorID == 1) then
        DCEI.LogMessage("Generating tutorial floor 1.")
        SetRoomType(1,"Start")
        starterRoom = 1
        currentRoom = starterRoom
        ExploreRoom(starterRoom)
        SetRoomType(25, "Stairs")
        SetRoomType(8,"Shop")
        SetRoomType(20,"Treasure")
    else
        SetRoomType(5,"Start")
        starterRoom = 5
        currentRoom = starterRoom
        ExploreRoom(starterRoom)
        SetRoomType(11, "Stairs")
        SetRoomType(13,"Shop")
        SetRoomType(3,"Campsite")
    end
    


    returnList = RemoveDuplicates(returnList)
    for i=1,GetTableSize(returnList) do
        --DCEI.LogMessage(" >>>  Got room ID:"..returnList[i])
    end
    local furthestRoom = 0
    local furthestDistance = 0
    foreach(returnList, function(roomID)
        local dist = GetMapDistance(starterRoom,roomID,returnList)
        if(dist >= furthestDistance) then
            furthestDistance = dist
            furthestRoom = roomID
        end
        distanceFromRoomToStart[roomID] = dist
       -- DCEI.LogMessage("Got room :"..roomID.." distance from start to be: "..dist)
    end)
    foreach(returnList, function(roomID)
        if(GetRoomType(roomID) == "Elite" and floorID == 1 and dungeonData.difficulty <= 5) then
            SetRoomType(roomID,"Combat") 
        end
        
        --Validate distance measurements.
        local distance = distanceFromRoomToStart[roomID]
        local adjacent = GetAllPossibleAdjacentRooms(roomID)
        foreach(adjacent, function(nearbyRoom)
            if(TableContains(returnList,nearbyRoom)) then
                local theirDistance = distanceFromRoomToStart[nearbyRoom]
                if(theirDistance == distance or theirDistance+1 == distance or theirDistance-1 == distance) then
                    --Distance validation good!
                else
                    --Distance validation is bad. Either their distance is wrong, or ours is.
                    if(distance > theirDistance+1) then
                        --Our distance is too large!
                        distanceFromRoomToStart[roomID] = theirDistance + 1
                        --DCEI.LogMessage("Distance validation FAILED for point: "..roomID.." got original distance: "..distance.." :: Setting to: "..(theirDistance+1).." (via point: "..nearbyRoom..")")
                    elseif(theirDistance > distance + 1) then
                    --DCEI.LogMessage("Distance validation FAILED for point: "..nearbyRoom.." got original distance: "..theirDistance.." :: Setting to: "..(distance+1).." (via point: "..roomID..")")
                        --Their distance is too large!
                        distanceFromRoomToStart[nearbyRoom] = distance + 1
                    end
                end
            end
            
        
        end)

        --Finished validation of distance
        
        --DCEI.LogMessage("Doing post-checks for room ID:"..roomID.." of type: "..GetRoomType(roomID))
        --[[if(GetAdjacentRoomsCount(roomID,returnList) == 1 and GetRoomType(roomID) == "Combat") then --Combat rooms should never be dead ends. These should be elite fights or treasures!
            if(RandomChance(80)) then
                SetRoomType(roomID,"Elite")
                --DCEI.LogMessage("Setting one adjacent combat room to type Event.")
            elseif(HasAdjacentRoomOfType(roomID,"Treasure",returnList) == false) then
                SetRoomType(roomID,"Treasure")
            else
                SetRoomType(roomID,"Campsite")
            end
        end
        if(GetRoomType(roomID) == "Combat" and HasAdjacentRoomOfType(roomID,"Combat",returnList) == true) then
            --DCEI.LogMessage(" >> Got combat adjacency for room ID:"..roomID)
            if( (RandomChance(25) and GetRoomCount("Event",returnList) < 2) or GetRoomCount("Event",returnList) < 1) then
                SetRoomType(roomID,"Event")
                --DCEI.LogMessage("Setting one adjacent combat room to type Event.")
            elseif(GetRoomCount("Shop",returnList) < 1) then
                SetRoomType(roomID,"Shop")
            elseif(GetRoomCount("Treasure",returnList) < 1 and (floorID >= 2 or RandomChance(15))) then
                SetRoomType(roomID,"Treasure")
            elseif(GetRoomCount("Campsite",returnList) < 1 and RandomChance(20)) then
                SetRoomType(roomID,"Campsite")
            end
            
        end]]
        --[[if(GetRoomType(roomID) == "Treasure" and HasAdjacentRoomOfType(roomID,"Treasure",returnList) == true) then
            --DCEI.LogMessage(" >> Got treasure adjacency for room ID:"..roomID)
            if(RandomChance(80) and GetRoomCount("Event",returnList) < 2) then
                SetRoomType(roomID,"Event")
                --DCEI.LogMessage("Setting one adjacent treasure room to type Event.")
            else
                --DCEI.LogMessage("Allowing one adjacent treasure room to have adjacent treasure spot.")
                --SetRoomType(roomID,"Combat") 
            end
            
        end
        if(GetRoomType(roomID) == "Shop" and HasAdjacentRoomOfType(roomID,"Shop",returnList)) then
            --DCEI.LogMessage(" >> Got shop adjacency for room ID:"..roomID)
            if(RandomChance(50) and GetRoomCount("Event",returnList) < 2) then
                SetRoomType(roomID,"Event")
                --DCEI.LogMessage("Setting one adjacent shop room to type Event.")
            else
                SetRoomType(roomID,"Combat") 
            end
            
        end]]
        if(GetRoomType(roomID) == "Combat" or GetRoomType(roomID) == "Elite") then
            local difficultyLevel = GetRandomNumber(0+floorID,7+floorID)
            if(AreRoomsAdjacent(topRoom,roomID)) then
                difficultyLevel = difficultyLevel + 3
            end
            if(distanceFromRoomToStart[roomID] <= 2) then
                difficultyLevel = GetRandomNumber(1,4+(floorID))
            end
            if(GetRoomType(roomID) == "Elite") then
                difficultyLevel = 10 + GetRandomNumber(floorID,6+floorID)
            end
            roomDifficulty[roomID] = difficultyLevel
            --DCEI.LogMessage("Set difficulty of room:"..roomID.." to:"..difficultyLevel)
            
        else
            
            roomDifficulty[roomID] = 0
        end
    
    end)

    local checks = 0
    local passedValidation = false

    while(passedValidation == false and checks < 20) do
        checks = checks+1
        passedValidation = MapDistanceValidation(returnList)
        DCEI.LogMessage("Doing map vaildation... pass: "..checks)
        
    end
    furthestDistance = 0
    foreach(returnList, function(roomID)
        specialRoomModifiers[roomID] = "None"
        local dist = distanceFromRoomToStart[roomID]
        if(dist >= furthestDistance) then
            furthestDistance = dist
            furthestRoom = roomID
            --DCEI.LogMessage("Got furthest room from start to be room ID:"..roomID.." with distance:"..furthestDistance)
        end
        --distanceFromRoomToStart[roomID] = dist
        if(GetRoomType(roomID) == "Stairs" or (GetRoomType(roomID)== "Treasure" and RandomChance(20)) or (GetRoomType(roomID)== "Elite" and RandomChance(100-(10*heroicLevel))) or 
        (GetRoomType(roomID)== "Combat" and RandomChance(70)) or (GetRoomType(roomID)== "Campsite" and RandomChance(90)) or (GetRoomType(roomID)== "Shop" and RandomChance(85))
            
        )then
            ForceExploreRoom(roomID)
        end
        --DCEI.LogMessage("Got room :"..roomID.." distance from start to be: "..dist)
    end)
    --[[if(isTopFloor == false) then
        --SetRoomType(furthestRoom,"Stairs")
        ForceExploreRoom(furthestRoom)
    end
    
    if(GetRoomCount("Stairs",returnList) < 1 and isTopFloor == false) then
        SetRoomType(furthestRoom,"Stairs")
        --DCEI.LogMessage("WARNING -- Invalid map was generated without stairs on lower level, force-adding stairs! Got stairs count: "..GetRoomCount("Stairs"))
        --DCEI.LogMessage("Room ID 23 is: "..roomTypes[23])
        if(GetRoomCount("Stairs",returnList) < 1 and isTopFloor == false) then
            SetRoomType(furthestRoom,"Stairs")
            --DCEI.LogMessage("WARNING -- Invalid map was generated without stairs on lower level, force-adding stairs!")
        end
        if(GetRoomCount("Stairs",returnList) < 1 and isTopFloor == false) then
            SetRoomType(furthestRoom,"Stairs")
            DCEI.LogMessage("WARNING -- Invalid map was generated without stairs on lower level, force-adding stairs!")
        end
    end]]
    --[[local distFromStartToStairs = GetMapDistance(starterRoom,topRoom,returnList)
    DCEI.LogMessage("Got Map distance: "..distFromStartToStairs)

    local distFromStartToCenter = GetMapDistance(starterRoom,13,returnList)
    DCEI.LogMessage("Got Center Map distance: "..distFromStartToCenter)

    local distFromStartToRand = GetMapDistance(starterRoom,randomRoom,returnList)
    DCEI.LogMessage("Got Random Map point: "..forcedShopRoom.." distance: "..distFromStartToRand)]]
    return returnList

end

function MapDistanceValidation(sourceMap)
    local passedValidation = true
    foreach(sourceMap, function(roomID)
        --Validate distance measurements.
        local distance = distanceFromRoomToStart[roomID]
        local adjacent = GetAllPossibleAdjacentRooms(roomID)
        foreach(adjacent, function(nearbyRoom)
            if(TableContains(sourceMap,nearbyRoom)) then
                local theirDistance = distanceFromRoomToStart[nearbyRoom]
                if(theirDistance == distance or theirDistance+1 == distance or theirDistance-1 == distance) then
                    --Distance validation good!
                else
                    --Distance validation is bad. Either their distance is wrong, or ours is.
                    if(distance > theirDistance+1) then
                        --Our distance is too large!
                        distanceFromRoomToStart[roomID] = theirDistance + 1
                        passedValidation = false
                        --DCEI.LogMessage("Distance validation FAILED for point: "..roomID.." got original distance: "..distance.." :: Setting to: "..(theirDistance+1).." (via point: "..nearbyRoom..")")
                    elseif(theirDistance > distance + 1) then
                    --DCEI.LogMessage("Distance validation FAILED for point: "..nearbyRoom.." got original distance: "..theirDistance.." :: Setting to: "..(distance+1).." (via point: "..roomID..")")
                        --Their distance is too large!
                        passedValidation = false
                        distanceFromRoomToStart[nearbyRoom] = distance + 1
                    end
                end
            end
            
        
        end)
    end)
    return passedValidation
end

function GetRoomCount(roomType, sourceMap)
    if(sourceMap == nil) then sourceMap = map end
    local returnCount = 0
    for index=1,25 do
        if(TableContains(sourceMap,index) == true) then
            if(GetRoomType(index) == roomType) then
                returnCount = returnCount + 1
            end
        end
    end
   --[[foreach(roomTypes, function(t)
        if(t == roomType) then
            returnCount = returnCount + 1
        end
    end)]]
    --DCEI.LogMessage("Getting room count of type: "..roomType.." returning count: "..returnCount)
    return returnCount
end


function GetMapDistance(sourcePoint, targetPoint, mapToCheck, distanceSoFar, log, nodesChecked)
    
    if(distanceSoFar == nil) then distanceSoFar = 0 end
    --[[if(distanceSoFar == 0 and ArePointsConnected(sourcePoint,targetPoint, mapToCheck, 0)) then
        DCEI.LogMessage("WARNING : Tried to get the distance of two points that are not connected! :: "..sourcePoint.." and "..targetPoint)
        return -1
    end]]
    if(sourcePoint == nil or targetPoint == nil) then
        return -1
    end
    --DCEI.LogMessage("Get Map Distance checking node: "..sourcePoint.." to "..targetPoint)
    if(TableContains(mapToCheck,sourcePoint) == false) then
        return -1
    end
    if(targetPoint == sourcePoint and TableContains(mapToCheck,targetPoint)) then
        --DCEI.LogMessage("INFO : Distance check branch got a viable distance measurement:"..distanceSoFar)
        return distanceSoFar
    end
    if(distanceSoFar >= 35) then
        --DCEI.LogMessage("WARNING : Distance check expiring branch for sourcepoint:"..targetPoint)
        return -1
    end
    if(nodesChecked == nil) then
        nodesChecked = {}
    end
    table.insert(nodesChecked,sourcePoint)
    local nextNode = GetRoomInDirection(sourcePoint,"Up")
    local upDistance = -1
    if(TableContains(nodesChecked,nextNode) == false) then
        upDistance = GetMapDistance(nextNode,targetPoint,mapToCheck,distanceSoFar + 1,log,nodesChecked)
    end

    nextNode = GetRoomInDirection(sourcePoint,"Down")
    local downDistance = -1
    if(TableContains(nodesChecked,nextNode) == false) then
        downDistance = GetMapDistance(nextNode,targetPoint,mapToCheck,distanceSoFar + 1,log,nodesChecked)
    end

    nextNode = GetRoomInDirection(sourcePoint,"Right")
    local rightDistance = -1
    if(TableContains(nodesChecked,nextNode) == false) then
        rightDistance = GetMapDistance(nextNode,targetPoint,mapToCheck,distanceSoFar + 1,log,nodesChecked)
    end

    nextNode = GetRoomInDirection(sourcePoint,"Left")
    local leftDistance = -1
    if(TableContains(nodesChecked,nextNode) == false) then
        leftDistance = GetMapDistance(nextNode,targetPoint,mapToCheck,distanceSoFar + 1,log,nodesChecked)
    end
    
    
    --local downDistance = GetMapDistance(GetRoomInDirection(sourcePoint,"Down"),targetPoint,mapToCheck,distanceSoFar + 1,log)
    --local rightDistance = GetMapDistance(GetRoomInDirection(sourcePoint,"Left"),targetPoint,mapToCheck,distanceSoFar + 1,log)
    --local leftDistance = GetMapDistance(GetRoomInDirection(sourcePoint,"Right"),targetPoint,mapToCheck,distanceSoFar + 1,log)
    local possibleDistances = {}
    if(upDistance >= 0) then table.insert(possibleDistances, upDistance) end
    if(downDistance >= 0) then table.insert(possibleDistances, downDistance) end
    if(rightDistance >= 0) then table.insert(possibleDistances, rightDistance) end
    if(leftDistance >= 0) then table.insert(possibleDistances, leftDistance) end

    local lowestDistance = 500
    for index=1,GetTableSize(possibleDistances) do
        if(possibleDistances[index] < lowestDistance) then
            lowestDistance = possibleDistances[index]
        end
    end
    if(lowestDistance < 500) then
        return lowestDistance
    else
        return -1
    end
    
end

function ArePointsConnected(sourcePoint, targetPoint, mapToCheck, checksMade, log)
    return GetMapDistance(sourcePoint,targetPoint,mapToCheck,checksMade,log) >= 0
end

--[[function ArePointsConnected(sourcePoint, targetPoint, mapToCheck, checksMade, log)
    --if(originalPoint == nil) then originalPoint = sourcePoint end
    if(checksMade == nil) then checksMade = 0 end
    if(sourcePoint == nil or targetPoint == nil) then
        return false
    end
    if(TableContains(mapToCheck,sourcePoint) == false) then
        return false
    end
    if(targetPoint == sourcePoint and TableContains(mapToCheck,targetPoint)) then
        return true
    end
    if(checksMade >= 8) then
        return false
    end
    return ArePointsConnected(GetRoomInDirection(sourcePoint,"Up"),targetPoint,mapToCheck,checksMade + 1,log) or ArePointsConnected(GetRoomInDirection(sourcePoint,"Down"),targetPoint,mapToCheck,checksMade + 1,log) or ArePointsConnected(GetRoomInDirection(sourcePoint,"Left"),targetPoint,mapToCheck,checksMade + 1,log) or ArePointsConnected(GetRoomInDirection(sourcePoint,"Right"),targetPoint,mapToCheck,checksMade + 1,log)
end]]

  -- Has a given chance (between 1-100) to return true based on the integer provided.
  function RandomChance(chance)
    if(chance == 0) then return false end
    return math.random(0,100) <= chance
  end

  function GetEnemyType(unitName)
    local enemyTypeCount = GetTableSize(ENEMY_TYPES)
    for index = 1, enemyTypeCount do
        local enemy = ENEMY_TYPES[index]
        if(enemy.name == unitName) then
            return enemy
        end
    end
    return nil
  end

  function IncreaseDungeonLevel()
    if(heroicLevel >= 1) then
        currentDungeonLevel = (currentDungeonLevel + (2 + difficultyScaleFactor)) + (currentDungeonLevel / 15)
    else
        currentDungeonLevel = (currentDungeonLevel + (1.0 + difficultyScaleFactor))
    end
    
  end

  local GOLD_MULTIPLIER = 1
  function GetLoot(difficulty, treasureRoom)
    if(difficulty == nil) then difficulty = currentDungeonLevel end
    local treasureModifier = 0
    if(treasureRoom == true) then
        treasureModifier = 1
    end
    local goldCount = 2 + roomDifficulty[currentRoom] + currentFloor + ((GetRandomNumber(18,32))*treasureModifier) + math.random(math.floor(difficulty * 0.25), math.floor(difficulty * 0.75))
    if(eliteFight == true) then
        goldCount = goldCount * 1.25
        goldCount = goldCount + (10*currentFloor)
    end
    if(playerGold >= 250 and currentFloor < currentDungeonFloors) then
        goldCount = goldCount / 2
        
    elseif(playerGold < 200 and currentFloor == currentDungeonFloors) then
        goldCount = goldCount * 1.5
    end
    if(playerGold >= 600) then
        goldCount = goldCount / 2
    end
    if(objectivesComplete == true) then
        goldCount = goldCount / 10
    end
    goldCount = goldCount * GOLD_MULTIPLIER
    goldCount = math.ceil( (goldCount) )
    local lootTable = {}
    local healthPotionCount = treasureModifier
    if(eliteFight) then healthPotionCount = healthPotionCount + 2 end
    if(math.random(1,100) <= 10) then
        healthPotionCount = healthPotionCount + 1
        if(math.random(1,100) <= 30) then
            healthPotionCount = healthPotionCount + math.random(1,2)
        end
    end

    local boomPotionCount = 0
    if(math.random(1,100) <= 2 + (5*treasureModifier)) then
        boomPotionCount = 1
    end
    lootTable = { {name = "Gold", count = math.floor(goldCount)}, {name = "Health Potion", count = healthPotionCount},{name = "Bomb Brew", count = boomPotionCount}}
    if(treasureModifier >= 1) then
        local possibleObjects = {"Omnistone","Seer's Eye",GetRandomAffinityTome()}
        foreach(shopItems, function(item)
            if(item.flags ~= nil and item.flags.treasureItem ~= nil and item.flags.treasureItem == true) then
                table.insert(possibleObjects,item.name)
            end
        
        end)
        local objectToAdd = GetRandomElement(possibleObjects)
        table.insert(lootTable, {name = objectToAdd, count =  1})
    end
    --local willGetPerk = false
    local perkCountToGet = 0
    if(eliteFight == true) then
        perkCountToGet = perkCountToGet + 1
    else
        --levelsWithoutPerk = levelsWithoutPerk + 1
    end
    
    if(playerPower >= 100) then
        SetPlayerPower(0)
        perkCountToGet = perkCountToGet + 1
    end
    if(perkCountToGet > 0) then
        table.insert(lootTable, {name = "Perk", count = perkCountToGet})
    end
    return lootTable
  end

function GetAllUnits()
    local returnList = {}
    local enemyUnits = DCEI.FindUnitsByPlayerIdAsCollection(-1)
    local enemyCount = DCEI.GetCollectionSize(enemyUnits)
    local playerUnits = DCEI.FindUnitsByPlayerIdAsCollection(1)
    local playerUnitCount = DCEI.GetCollectionSize(playerUnits)

    for index = 1, enemyCount do
        local unit = DCEI.GetCollectionItem(enemyUnits,index)
        table.insert(returnList, unit)
    end

    for index = 1, playerUnitCount do
        local unit = DCEI.GetCollectionItem(playerUnits,index)
        table.insert(returnList, unit)
    end
    --DCEI.LogMessage("Get all units returning "..(playerUnitCount+enemyCount).. " units!")
    return {list = returnList, count = (playerUnitCount+enemyCount)}
end

function IsHelperUnit(unit)
    return DCEI.UnitBehaviorStackCount(unit,"Standard HelperTag") >= 1
end

function GetAllEnemies()
    local returnList = {}
    local enemyUnits = DCEI.FindUnitsByPlayerIdAsCollection(-1)
    local enemyCount = DCEI.GetCollectionSize(enemyUnits)
    --
    --DCEI.LogMessage("GetAllEnemies() called!")
    for index = 1, enemyCount do
        local unit = DCEI.GetCollectionItem(enemyUnits,index)
        if(IsHelperUnit(unit) == false) then
            --DCEI.LogMessage("Found non-helper enemy unit: "..DCEI.UnitName(unit))
            table.insert(returnList, unit)
            enemyCount = enemyCount + 1
        else
            --DCEI.LogMessage("Found helper unit: "..DCEI.UnitName(unit))
        end
        
        
    end
    return {list = returnList, count = (GetTableSize(returnList))}
end

function GetAllHeroes()
    local returnList = {}
    local heroUnits = DCEI.FindUnitsByPlayerIdAsCollection(1)
    local heroCount = 0
    for index = 1, DCEI.GetCollectionSize(heroUnits) do
        local unit = DCEI.GetCollectionItem(heroUnits,index)
        if(IsHeroUnit(unit)) then
            heroCount = heroCount + 1
            table.insert(returnList, unit)
            --DCEI.LogMessage("Found hero unit: "..DCEI.UnitName(unit))
        end
        
    end
    return {list = returnList, count = (heroCount)}
end

function HighlightKeywords(inputText)
    local returnValue = inputText
    returnValue = returnValue:gsub( "Trait:", "<color=#FCFF50>Trait:</color>" )
    returnValue = returnValue:gsub( "Special Ability:", "<color=green>Special Ability:</color>" )
    returnValue = returnValue:gsub( "heroes", "<color=#86d7ff>heroes</color>" )
    returnValue = returnValue:gsub( "Shield", "<color=#BDF4FF>Shield</color>" )
    returnValue = returnValue:gsub( "attack speed", "<color=yellow>attack speed</color>" )

    returnValue = returnValue:gsub( "Aqua", "<color=#66ccff>Aqua</color>" )
    returnValue = returnValue:gsub( "Pyro", "<color=#ff4d4d>Pyro</color>" )
    returnValue = returnValue:gsub( "Naturalists", "<color=#79ff4d>Naturalists</color>" )
    returnValue = returnValue:gsub( "Naturalist", "<color=#79ff4d>Naturalist</color>" )
    
    returnValue = returnValue:gsub( "Holy", "<color=#ffff80>Holy</color>" )
    returnValue = returnValue:gsub( "Armored", "<color=#4d79ff>Armored</color>" )
    returnValue = returnValue:gsub( "Tricksters", "<color=#ff66a3>Tricksters</color>" )
    returnValue = returnValue:gsub( "Trickster", "<color=#ff66a3>Trickster</color>" )

    returnValue = returnValue:gsub( "Brawlers", "<color=#ff3333>Brawlers</color>" )
    returnValue = returnValue:gsub( "Brawler", "<color=#ff3333>Brawler</color>" )

    returnValue = returnValue:gsub( "Rangers", "<color=#ff3333>Rangers</color>" )
    returnValue = returnValue:gsub( "Ranger", "<color=#ff3333>Ranger</color>" )
    returnValue = returnValue:gsub( "Hasted", "<color=#00ffaa>Hasted</color>" )
    
    returnValue = returnValue:gsub( "Spellshield", "<color=#99ccff>Spellshield</color>" )
    returnValue = returnValue:gsub( "Block", "<color=#99ccff>Block</color>" )
    returnValue = returnValue:gsub( "Spellcasters", "<color=#bf80ff>Spellcasters</color>" )
    returnValue = returnValue:gsub( "Spellcaster", "<color=#bf80ff>Spellcaster</color>" )
    returnValue = returnValue:gsub( "Specialists", "<color=#bf80ff>Specialists</color>" )
    returnValue = returnValue:gsub( "Specialist", "<color=#bf80ff>Specialist</color>" )
    
    returnValue = returnValue:gsub( "Stealthed", "<color=#6666ff>Stealthed</color>" )
    returnValue = returnValue:gsub( "Stealth", "<color=#6666ff>Stealth</color>" )
    returnValue = returnValue:gsub( "Polymorph", "<color=#80ffff>Polymorph</color>" )
    returnValue = returnValue:gsub( "Undead", "<color=#bf80ff>Undead</color>" )
    returnValue = returnValue:gsub( "Mobile", "<color=#ffcc99>Mobile</color>" )
    returnValue = returnValue:gsub( "Poisoned", "<color=#29a329>Poisoned</color>" )
    returnValue = returnValue:gsub( "Poison", "<color=#29a329>Poison</color>" )
    returnValue = returnValue:gsub( "Nightmare", "<color=#5330ff>Nightmare</color>" )
    returnValue = returnValue:gsub( "damage dealt", "<color=#fc3030>damage dealt</color>" )
    
    --returnValue = returnValue:gsub( "Special Ability", "<color=green>Special Ability</color>" )
    return returnValue
end


-- FUNCTIONS

-- Generates an "Encounter" object based on a given difficulty level. 
-- Each encounter has:
    -- Difficulty (1-1000)
    -- A table of "required" units (by name). These units will be spawned regardless of the given difficulty level.
    -- For any excess units after the required ones, random units will be picked to suit the remaining difficulty level required.
    -- An encounter can only have up to 18 enemy units total (Including 3 structures). Any additional difficulty after this is achieved by adding stacking buffs to all units.
function GenerateEncounter(difficulty, requiredUnits, isElite, isAmbush, isNightmare)
    isEncounterActive = true
    if(roomsCleared < 5 and isElite == false) then
        difficulty = difficulty * 0.65
    end
    if(difficulty > (5+heroicLevel)*PARTY_SIZE and PARTY_SIZE <= 3) then
        difficulty = (5+heroicLevel)*PARTY_SIZE
    end
    if(requiredUnits == nil) then requiredUnits = {} end
    if(roomsCleared == 1) then
        table.insert(requiredUnits, "Witch")
    end
    DCEI.LogMessage("Generating encounter with difficulty: "..difficulty)
    if(isNightmare) then
        DCEI.LogMessage("Generating NIGHTMARE encounter!")
        isElite = RandomChance( math.ceil(threatLevel+5) - 110)
        if(isElite) then
            table.insert(requiredUnits, "Deathspeaker")
        end
        table.insert(requiredUnits, "Nightmare Abomination")
        --table.insert(requiredUnits, "Herald")
        --table.insert(requiredUnits, "Witch")
        --table.insert(requiredUnits, "Bone Archer")
        --table.insert(requiredUnits, "Bone Archer")
        table.insert(affinityTokens,"Nightmare")
    end
    if(isAmbush and threatLevel >= 120) then
        isElite = RandomChance( math.ceil(threatLevel+10) - 100)
        table.insert(requiredUnits, "Deathspeaker")
        --table.insert(requiredUnits, "Bone Warrior")
    end
    local bonusDifficulty = roomDifficulty[currentRoom]
    if(roomsCleared <= 5) then
        bonusDifficulty = math.floor(bonusDifficulty * 0.5)
    end
    local difficultyRemaining = difficulty + bonusDifficulty
    local availableSpawnPoints = table.clone(enemySpawnPoints)
    --DCEI.LogMessage("Available spawn points: "..GetTableSize(enemySpawnPoints))
    local spawnedEnemiesCount = 0
    local spawnedStructuresCount = 0
    local spawnedEnemies = {}
    local dangerZonesToCreate = 0
    if(isElite) then eliteFight = true end
    if(isElite) then
        DCEI.LogMessage(" --- Generated encounter is ELITE difficulty.")
        requiredUnits = {}
        for index=1,currentFloor do
            table.insert(requiredUnits, "Deathspeaker")
            --table.insert(requiredUnits, "Bone Warrior")
            --table.insert(requiredUnits, "Bone Warrior")
        end
        --table.insert(requiredUnits, "Deathspeaker")
    end
    if(requiredUnits ~= nil) then
        local requiredUnitsCount = GetTableSize(requiredUnits)
        for index=1, requiredUnitsCount do
            local enemy = GetEnemyType(requiredUnits[index])
            difficultyRemaining = difficultyRemaining - enemy.difficulty
            local randomIndex = GetRandomIndex(availableSpawnPoints)
            randomPosition = table.remove( availableSpawnPoints, randomIndex )
            local createdUnit = DCEI.CreateUnitWithFacing(-1,-1,enemy.name,randomPosition.x,randomPosition.y,270,0)
            --CreateUnitBar(createdUnit,true)
            if(DCEI.UnitName(createdUnit) == "Witch") then
                dangerZonesToCreate = dangerZonesToCreate + 1
            end
            spawnedEnemiesCount = spawnedEnemiesCount + 1
            table.insert(spawnedEnemies, createdUnit)
        end
    end
    local failedSpawns = 0
    while(difficultyRemaining > 0) do
        if((spawnedEnemiesCount >= GetTableSize(enemySpawnPoints) or (difficulty > 20 and spawnedEnemiesCount >= 5 and RandomChance(spawnedEnemiesCount*4))) or (failedSpawns > 5 and spawnedEnemiesCount >= 5)) then
            --Add additional difficulty behaviors.
            difficultyRemaining = difficultyRemaining - 1
            local randomSpawnedEnemy = GetRandomElement(spawnedEnemies)
            DCEI.ApplyBehaviorCount(randomSpawnedEnemy,"Difficulty Mod",1)
            --DCEI.LogMessage("Applied difficulty stack to enemy unit: "..DCEI.UnitName(randomSpawnedEnemy))
        else
            local randomEnemy = GetRandomElement(ENEMY_TYPES)
            if((EnemyIsElite(randomEnemy) == false or isElite == true) and EnemyIsNightmare(randomEnemy) == false) then
                local createEnemy = true
                if(randomEnemy.name == "Unholy Altar") then
                    if((spawnedEnemiesCount < 5 or difficulty < 15 ) or spawnedStructuresCount >= 3) then
                        createEnemy = false
                    else
                        spawnedStructuresCount = spawnedStructuresCount + 1
                    end
                end
                if(randomEnemy.difficulty > (difficultyRemaining+5) and difficulty <= 40) then
                    createEnemy = false
                    failedSpawns = failedSpawns + 1
                end
                if(isElite and RandomChance(20)) then createEnemy = false end --Even on elite levels, we dont want elite mobs spawning as often as normal mobs do.
                if(createEnemy) then
                    difficultyRemaining = difficultyRemaining - randomEnemy.difficulty
                    local randomIndex = GetRandomIndex(availableSpawnPoints)
                    randomPosition = table.remove( availableSpawnPoints, randomIndex )
                    local createdUnit = DCEI.CreateUnitWithFacing(-1,-1,randomEnemy.name,randomPosition.x,randomPosition.y,270,0)
                    --CreateUnitBar(createdUnit,true)
                    if(DCEI.UnitName(createdUnit) == "Witch") then
                        dangerZonesToCreate = dangerZonesToCreate + 1
                    end
                    spawnedEnemiesCount = spawnedEnemiesCount + 1
                    table.insert(spawnedEnemies, createdUnit)
                end
            else
                
            end
            
            
        end
        
    end
    if(isAmbush ~= nil and isAmbush == true and threatLevel > 30) then
        foreach(spawnedEnemies, function(unit)
            DCEI.ApplyBehaviorCount(unit,"Difficulty Mod",1)
            
        end)
    end
    if(threatLevel > 75) then
        foreach(spawnedEnemies, function(unit)
            DCEI.ApplyBehaviorCount(unit,"Difficulty Mod",1)
            
        end)
    end
    if(isNightmare) then
        DCEI.LogMessage("Applying "..(GetAffinityTokenCount("Nightmare")).."Nightmare stacks to enemies!")
        foreach(spawnedEnemies, function(unit)
            DCEI.ApplyBehaviorCount(unit,"Nightmare",GetAffinityTokenCount("Nightmare")-1)
        end)
    end
    
    --DCEI.ShowFeedbackMessage("Room: <color=yellow>"..(roomsCleared+1))
    SpawnHeroes()
    PacifyAllUnits()
    DCEI.Wait(0)
    
    ApplyPreBattlePerks()
    DCEI.Wait(0)
    HandleDangerZones(dangerZonesToCreate)
    UpdateActiveAffinities()
    
    PauseAllUnits()
    DCEI.Wait(0)
    UpdateActiveAffinities()
    
end

function HandleDangerZones(zonesToCreate)
    dangerZones = {}
    for index=1,zonesToCreate do
        
        local zonePos = GetRandomHeroPosition()
        CreateDangerZone(zonePos)
        --DCEI.CreateUnit(-1,-1,"Decay Dummy Unit",zonePos.x,zonePos.y)
        --[[local newZone = GetRandomIndex(hexGrid)
        table.insert(dangerZones,index)
        DCEI.LogMessage("Creating danger zone @ index:"..newZone)
        ]]
    end

    UpdateHexGrid()
end

function CreateDangerZone(targetPosition)
    DCEI.CreateUnit(-1,-1,"Decay Dummy Unit",targetPosition.x,targetPosition.y)
end

function SpawnHeroes()
    for index = 1, PARTY_SIZE do
        local indexToUse = index
        if(index > GetTableSize(defaultSpawns)) then
            indexToUse = GetRandomNumber(2,6)
        end
        local preferredDefaultSpawn = GetEmptyHexPoint()
        local preferredPositionX = preferredDefaultSpawn.x + snapOffset.x
        local preferredPositionY = preferredDefaultSpawn.y + snapOffset.y
        if(partyUnitPosition[index] ~= nil) then
            preferredPositionX = partyUnitPosition[index].x
            preferredPositionY = partyUnitPosition[index].y
        else
            partyUnitPosition[index] = {x=preferredDefaultSpawn.x + snapOffset.x, y=preferredDefaultSpawn.y + snapOffset.y}
        end
        if(partyUnitHealth[index] ~= nil and partyUnitHealth[index] <= 0) then
            party[index] = nil
        else
            local createdUnit = DCEI.CreateUnit(1,1,partyUnits[index],preferredPositionX,preferredPositionY)
            party[index] = createdUnit
            CreateUnitBar(createdUnit,false)
            if(partyUnitHealth[index] ~= nil) then
                DCEI.SetHealthValue(createdUnit, partyUnitHealth[index], DCEI.UnitTypeHealth(partyUnits[index]))
            end
        end
        
        SetOccupiedHexPoints()
    end
    DCEI.LogMessage("Combat dialog init-- showing hex grid.")
    ToggleHexGrid(true)
end

function UpdateTargetableHeroes()
    if(repositionModeActive == true or battleOngoing == false) then return end
    --DCEI.LogMessage("Updating targetable heroes.")
    foreach(party, function(heroUnit) 
        if(heroUnit ~= nil and DCEI.GetManaValue(heroUnit) < MANA_COST) then
            --DCEI.LogMessage("Marking unit:"..DCEI.UnitType(heroUnit).." as untargetable due to energy levels!")
            DCEI.DisableUnitSelection(heroUnit)
        elseif(heroUnit ~= nil) then
            DCEI.EnableUnitSelection(heroUnit)
        end
    end)
    DCEI.Wait(.5)
    UpdateTargetableHeroes()
end

function ClearAllUnits()
    local unitsCollection = GetAllUnits()
    local allUnits = unitsCollection.list
    local totalUnitCount = unitsCollection.count
    
    for index = 1, totalUnitCount do
        if(allUnits[index] ~= ITEM_CASTER and DCEI.UnitName(allUnits[index]) ~= "Point_Marker Alpha") then
            DCEI.RemoveUnit(allUnits[index])
        end
        
    end
    RemoveAllCastbars()
    ClearTooltips()
end

function PacifyAllUnits()
    local unitsCollection = GetAllUnits()
    local allUnits = unitsCollection.list
    local totalUnitCount = unitsCollection.count

    local enemyCollection = GetAllEnemies()
    local enemyUnits = enemyCollection.list
    local enemyCount = enemyCollection.count

    local index = 1

    
    for index = 1, totalUnitCount do
        if(allUnits[index] ~= ITEM_CASTER) then
            DCEI.ApplyBehavior(allUnits[index],"Pacify Unit")
        end

        
    end
    ClearTooltips()
end

function PauseAllUnits()
    local unitsCollection = GetAllUnits()
    local allUnits = unitsCollection.list
    local totalUnitCount = unitsCollection.count

    local enemyCollection = GetAllEnemies()
    local enemyUnits = enemyCollection.list
    local enemyCount = enemyCollection.count

    local index = 1
    for index = 1, enemyCount do
        local unit = enemyUnits[index]
        DCEI.SetUnitRotationEuler(unit,0,180,0)
        --DCEI.ApplyBehaviorCount(allUnits[index],"Vulnerable",50)
    end
    
    for index = 1, totalUnitCount do
        if(allUnits[index] ~= ITEM_CASTER) then
            DCEI.ApplyBehavior(allUnits[index],"Paused")
            DCEI.RemoveBehavior(allUnits[index],"Pacify Unit")
        end

        
    end
end

function UnpauseAllUnits()
    local unitsCollection = GetAllUnits()
    local allUnits = unitsCollection.list
    local totalUnitCount = unitsCollection.count
    
    for index = 1, totalUnitCount do
        if(IsHeroUnit(allUnits[index]) == false) then
            DCEI.RemoveBehavior(allUnits[index],"Paused")
        end
        
    end
    ExecuteAfter(function() 
        for index = 1, totalUnitCount do
            if(IsHeroUnit(allUnits[index]) == true) then
                DCEI.RemoveBehavior(allUnits[index],"Paused")
            end
            
        end
    end,.75)
end

--Conversations

local conversationStartMerc = {
    "Mercenary",
    "An intruder!",
    callback = function()
        DCEI.LogMessage("On Convo done called!")
    end
}

local conversationStartHero = {
    "Hero",
    "I'd better deal with these guys... Just give me the word!",
    callback = function()
        DCEI.LogMessage("On Convo done called!")
    end
}

function ShowConversation(conversation, conversationUnit)
    --options = {offset = {up = .65, front = 0, right = .2}}
    currentConversation = conversation
    currentConversationUnit = conversationUnit
    AdvanceConversation()
    --DCEI.ShowSpeechBubble(conversationUnit,35,conversation[2],conversation[1],options)
end

function AdvanceConversation()
    options = {offset = {up = .65, front = 0, right = .2}}
    currentConversationStage = currentConversationStage + 1
    DCEI.LogMessage("Advancing to convo stage>:"..currentConversationStage)
    if(currentConversation[currentConversationStage] ~= nil) then
        DCEI.HideSpeechBubble(currentConversationUnit)
        DCEI.ShowSpeechBubble(currentConversationUnit,85,currentConversation[currentConversationStage],currentConversation[1],options)
    else
        DCEI.HideSpeechBubble(currentConversationUnit)
        currentConversation.callback()
        currentConversation = nil
        currentConversationUnit = nil
        currentConversationStage = 1
    end
end

function OnAnyButtonClick()
    if(currentConversation ~= nil) then
        AdvanceConversation()
    end
end
    
function OnHeroUnitSelected(unit)
    
    --DCEI.LogMessage("A hero unit was selected!")
    local triggeringUnit = unit
    DCEI.DeselectUnit(triggeringUnit)
    local wasHeroSelected = (DCEI.GetUnitPlayerId(triggeringUnit) == 1)
    if(battleOngoing and DCEI.GetManaValue(triggeringUnit) >= MANA_COST ) then
        --UseSignatureAbility(triggeringUnit)
    elseif(battleOngoing == false and (repositionModeActive == false --[[or IsHeroUnit(triggeringUnit) == false)]] )) then
        if(IsHeroUnit(triggeringUnit) == false) then
            CreateInspectUnitDialog(triggeringUnit)
        end
        
    end

    --[[if(wasHeroSelected == false) then
        return
    end
    if(repositionModeActive) then
        selectedUnit = triggeringUnit
        local excludedIndex = GetClosestHexIndexToPoint(DCEI.GetUnitPosition2D(selectedUnit))
        SetOccupiedHexPoints(excludedIndex)
        
        
        --DCEI.LogMessage("A hero unit was selected for repositioning!")
        return
    end]]
end

function OnUnitDraggedDown(unit)
    local triggeringUnit = unit
    DCEI.DeselectUnit(triggeringUnit)
    local wasHeroSelected = (DCEI.GetUnitPlayerId(triggeringUnit) == 1)
    if(wasHeroSelected == false) then
        return
    end
    if(repositionModeActive) then
        selectedUnit = triggeringUnit
        local excludedIndex = GetClosestHexIndexToPoint(DCEI.GetUnitPosition2D(selectedUnit))
        SetOccupiedHexPoints(excludedIndex)
        
        
        --DCEI.LogMessage("A hero unit was selected for repositioning!")
        return
    end
end

local mouseDownLocation = {}
local lastSelected = nil
function OnMouseDown(point, mousedUnit)
    
        OnAnyButtonClick()
        if(repositionModeActive == true and IsHeroUnit(mousedUnit) and mousedUnit ~= nil) then
            OnUnitDraggedDown(mousedUnit) --Handles pre-combat repositioning and dragging.
        elseif(mousedUnit ~= nil) then
            OnHeroUnitSelected(mousedUnit)--Handles in-combat stuff.
        else
            DCEI.CreateUnit(1,1,"SmokeUnit",point.x,point.y)
        end
end



function OnRightMouseDown(point, selectedUnit)
    ClearInspectDialog()
    mouseDownLocation = point
    DCEI.LogMessage("Mouse down location @:"..point.x .. ", "..point.y)
    if(selectedUnit ~= nil) then
        DCEI.LogMessage("Mouse down got selected unit:"..DCEI.UnitName(selectedUnit))
        lastSelected = selectedUnit
        if(battleOngoing) then
            DCEI.ApplyBehaviorWithDuration(selectedUnit,"Being Ordered",1.5,false)
        end
    end

end

function OnRightMouseRelease()
    if(targetingModeActive == true) then return end
    local point = DCEI.GetMousePosition2D()
    local dragDistance = GetSquaredDistanceBetweenPoints(point,mouseDownLocation)
    DCEI.LogMessage("Got drag distance (squared) = "..dragDistance)
    if(repositionModeActive == false) then
        if(dragDistance >= 0.435 and battleOngoing == true and lastSelected ~= nil and DCEI.UnitBehaviorStackCount(lastSelected,"Mobile") >= 1) then
            DCEI.LogMessage("Issuing in-combat move order to:"..DCEI.UnitName(lastSelected))
            OrderUnitMovement(lastSelected, point, dragDistance)
        elseif(lastSelected ~= nil) then
            --OnHeroUnitSelected(lastSelected)
        end
    end
    mouseDownLocation = nil
end
local hasRepositioned = false
function OnMouseRelease()
    local point = DCEI.GetMousePosition2D()
    --DCEI.LogMessage("Mouse UP location @:"..point.x .. ", "..point.y)
    --local dragDistance = GetSquaredDistanceBetweenPoints(point,mouseDownLocation)
    --DCEI.LogMessage("Got drag distance (squared) = "..dragDistance)
    
    
    
    if(repositionModeActive and selectedUnit ~= nil) then
        --DCEI.LogMessage("Deselecting dragged repo unit.")
        local selectedUnitIndex = 0
        for index=1, PARTY_SIZE do
            if(party[index] == selectedUnit) then
                selectedUnitIndex = index
            end
        end
        partyUnitPosition[selectedUnitIndex] = DCEI.GetUnitPosition2D(selectedUnit)
        selectedUnit = nil
        SetOccupiedHexPoints()
        if(roomsCleared == 1) then
            hasRepositioned = true
            repositionModeActive = false
        end
        

    end
    
    lastSelected = nil
end

function OrderUnitMovement(targetUnit, newLocation, distance)
    if(battleOngoing == true and IsHeroUnit(targetUnit)) then
        local oldLocation = DCEI.GetUnitPosition2D(targetUnit)
        DCEI.Move(targetUnit,newLocation.x, newLocation.y)
        DCEI.CreateUnit(1,1,"Waypoint Marker",newLocation.x,newLocation.y)
        DCEI.CreateUnit(1,1,"Waypoint Marker",oldLocation.x,oldLocation.y)
        DCEI.ApplyBehaviorWithDuration(targetUnit,"Ignore Collision",1.5,false)
        --DCEI.ApplyBehaviorWithDuration(partyUnit,"Stealth",4,false)
    end
end


function OnAnyAbilityUsed()
    local triggeringUnit = DCEI.TriggeringUnit
    local triggeringAbility = DCEI.TriggeringAbilityName
    if(targetingModeActive == true) then
        ClearTargetingMode()
        
    end
    if(triggeringUnit == ITEM_CASTER) then
        OnItemUsed(triggeringAbility)
    elseif(IsHeroUnit(triggeringUnit) and triggeringAbility ~= "Legion's Call") then
        --DCEI.LogMessage("Detected abil use: "..triggeringAbility.." by unit: "..DCEI.UnitName(triggeringUnit))
        --OnHeroicAbilityUsed(triggeringUnit)
    elseif(triggeringAbility == "Deathcall Cast") then
        DCEI.LogMessage("Detected abil use: "..triggeringAbility.." by unit: "..DCEI.UnitName(triggeringUnit))
        OnDeathcallerCast(triggeringUnit)
    end
    
end

function ExpectTarget(unit, abilityToUse)
    ClearTargetingMode()
    --ShowRelevantText("O")
    targetingModeActive = true
    --DCEI.SetUpdateFrequency(0.25)
    DCEI.ShowSlowMotionEffect()
    ShowTargetingDialog(abilityToUse)
    --DCEI.Wait(0.5)
    DCEI.EnterTargetingMode(unit, abilityToUse)
end

function ClearTargetingMode()
    targetingModeActive = false
    DCEI.ExitTargetingMode()
    DCEI.HideSlowMotionEffect()
    targetingModeActive = false
    DCEI.ClearUpdateFrequency()
    HideTargetingDialog()
end


function UseSignatureAbility(unit)
    local unitName = DCEI.UnitName(unit)
    local manaRemaining = DCEI.GetManaValue(unit)
    if(manaRemaining >= MANA_COST) then
        local abilityToUse = "Unknown"
        if(unitName == "Knight") then
            abilityToUse = "Inspire"
            DCEI.CastAbilityAtPosition(abilityToUse, unit, 0,0)
        elseif (unitName == "Archer") then --Legion's Call
            abilityToUse = "Heavy Arrow"
            ExpectTarget(unit, abilityToUse)
            --DCEI.CastAbilityAtPosition(abilityToUse, unit, 0,0)
        elseif (unitName == "Legionnaire") then --
            abilityToUse = "Legion's Call"
            DCEI.CastAbilityAtPosition(abilityToUse, unit, 0,0)
        elseif (unitName == "Priest") then
            abilityToUse = "Bless"
            ExpectTarget(unit, abilityToUse)
        elseif (unitName == "Protector") then
            abilityToUse = "Protect"
            ExpectTarget(unit, abilityToUse)
        elseif (unitName == "Rifleman") then
            abilityToUse = "Scattershot"
            ExpectTarget(unit, abilityToUse)
            
        elseif (unitName == "Berserker") then
            abilityToUse = "Enrage"
            DCEI.CastAbility(abilityToUse, unit, unit)
        elseif (unitName == "Assassin") then
            abilityToUse = "Sublety"
            DCEI.CastAbility(abilityToUse, unit, unit)
        elseif (unitName == "Alchemist") then
            abilityToUse = "Brew Potion"
            
            if(CanCast(unit)) then
                DCEI.CastAbility(abilityToUse, unit, unit)
                CreateUnitCastBar(unit, "Brew Potion", 2, function()
                    local createdItem = GetRandomElement(shopItemsToShow)
                    ClaimItem(createdItem)
                    DCEI.LogMessage("Alchemist brewing item: "..createdItem.name)
                    CreateRelevantUnitText(unit, "Brewed: "..createdItem.name)
                end)
            end
        elseif (unitName == "Pyromancer") then
            abilityToUse = "Ignite"
            ExpectTarget(unit, abilityToUse)
        elseif (unitName == "Druid") then
            abilityToUse = "Regrowth"
            ExpectTarget(unit, abilityToUse)
        else
            abilityToUse = "Unknown"
        end
        --DCEI.LogMessage("Ordering "..unitName.." to use "..abilityToUse)
        if(abilityToUse ~= "Unknown") then
            --OnHeroicAbilityUsed(unit)
        end
        
    else
        --DCEI.LogMessage(""..unitName.." can't use their ability because it isnt ready!")
    end
   
    
end

function BrewPotionCasted(context)
    local unit = context.source
    if(CanCast(unit)) then
        --DCEI.CastAbility(abilityToUse, unit, unit)
        CreateUnitCastBar(unit, "Brew Potion", 2, function()
            local createdItem = GetRandomElement(shopItemsToShow)
            ClaimItem(createdItem)
            DCEI.LogMessage("Alchemist brewing item: "..createdItem.name)
            CreateRelevantUnitText(unit, "Brewed: "..createdItem.name)
        end)
    end
end

function OnHeroicAbilityUsed(unit)
    --DCEI.LogMessage("On HeroicAbilityUsed Called!")
    
    for partyMemberId = 1, PARTY_SIZE do
        if(party[partyMemberId] ~= nil) then
            local unitName = DCEI.UnitName(party[partyMemberId])
        
            if(unitName == "Legionnaire" and party[partyMemberId] ~= unit) then
                DCEI.CastAbilityAtPosition("Legion's Call", party[partyMemberId],0,0)
            end
        end
        
    end

    --[[local deathcallerUnit = DCEI.FindUnit("Deathspeaker")
    if(deathcallerUnit ~= nil) then
        DCEI.LogMessage("Ordering deathcaller unit to use deathcall!")
        DCEI.CastAbility("Deathcall",deathcallerUnit,deathcallerUnit)
        --DCEI.PlaySound("lightning_bolt_v1")
    end]]
end


function AICastOozeSplit(context)
    --DCEI.LogMessage("AI_Casting Oozesplit Cast!")
    local sourceUnit = context.source
    DCEI.Wait(GetRandomNumber(0,20)/10.0)
    local castTimeBonus = (GetAllEnemies().count)*0.2
    if(castTimeBonus > 3.0) then castTimeBonus = 3.0 end
    if(CanCast(context.source)) then
        CreateUnitCastBar(sourceUnit,"Split",2.5+castTimeBonus, function()
            if(UnitIsAlive(sourceUnit)) then
                --DCEI.LogMessage("AI_Casting Oozesplit Cast Finish!")
                local pos = DCEI.GetUnitPosition2D(sourceUnit)
                DCEI.CreateUnit(-1,-1,DCEI.UnitName(sourceUnit),pos.x+(GetRandomNumber(0,5)/10),pos.y+(GetRandomNumber(0,5)/10))
            end
        
        end)
    end
end

function AICastWitchHex(context)
    --DCEI.LogMessage("AI_Casting Witchhex Cast!")
    local sourceUnit = context.source
    DCEI.Wait(GetRandomNumber(0,40)/10.0)
    if(CanCast(context.source)) then
        CreateUnitCastBar(sourceUnit,"Hex of Pain",2.0, function()
            if(UnitIsAlive(sourceUnit)) then
                --DCEI.LogMessage("AI_Casting Hex Cast Finish!")
                local pos = GetRandomHeroPosition()
                CreateDangerZone(pos)
            end
        
        end)
    end
end

function AICastDeathcall(context)
    --DCEI.LogMessage("AI_Casting Deathcall Cast!")
    local sourceUnit = context.source
    DCEI.Wait(GetRandomNumber(0,30)/10.0)
    if(CanCast(context.source)) then
        OnDeathcallerCast(sourceUnit)
    end
    
end

function OnDeathcallerCast(castingUnit)
    --DCEI.LogMessage("Deathcall used! -- creating cast bar!")
    CreateUnitCastBar(castingUnit,"Deathcall",(GetRandomNumber(29,40)/10.0), function()
        if(UnitIsAlive(castingUnit)) then
            DCEI.CastAbility("Deathcall",castingUnit,castingUnit)
        end
    end)
end

function OnUnitDied()
    --Check if the battle is finished.
    local dyingUnit = DCEI.TriggeringUnit
    
    if(DCEI.UnitType(dyingUnit) == "Unit" or DCEI.UnitType(dyingUnit) == "Structure") then
        --DCEI.LogMessage("Enemy Unit died! Unit Type: "..DCEI.UnitType(dyingUnit))
        if(DCEI.GetUnitPlayerId(dyingUnit) == -1 and IsHelperUnit(dyingUnit) == false) then
            enemiesRemaining = enemiesRemaining - 1
        
        end
        
        
        --local wasFinished = CheckBattleFinished()
        DCEI.Wait(1)
        CheckBattleFinished()
        --DCEI.Wait(2)
        --CheckBattleFinished()
        
        
        
    end
    --local remainingUnits = GetAllEnemies().count
end

function CheckBattleFinished()
    --DCEI.LogMessage("Enemy units remaining: "..enemiesRemaining.." /// "..GetAllEnemies().count)
    --DCEI.LogMessage("Friendly units remaining: "..GetAllHeroes().count)
    if(enemiesRemaining <= 0 and GetAllEnemies().count == 0) then
        OnBattleFinished(true)
        return true

    else
        if(GetAllHeroes().count == 0) then
            --DCEI.LogMessage("Defeat detected with hero count: "..GetAllHeroes().count)
            OnBattleFinished(false)
            return true
        end
    end
    
    return false
end

function PauseSimulation()

end

function OnBattleStarted()
    PlaySound("[Sound] Battle Start")
    DCEI.LogMessage("Battle started!")
    DCEI.HidePositionHelper()
    battleOngoing = true
    ClearInspectDialog()
    DCEI.LogMessage("Battle started! -- Postcall1.")
    UpdateInventoryUI()
    ToggleHexGrid(false)
    ToggleMapFrame(false)
    DCEI.LogMessage("Battle started! -- Postcall2.")
    repositionModeActive = false
    selectedUnit = nil
    enemiesRemaining = GetAllEnemies().count
    DCEI.LogMessage("Battle started! -- Postcall3.")
    --DCEI.LogMessage("[[START]] Enemy units remaining: "..enemiesRemaining.." /// "..GetAllEnemies().count)
    --DCEI.LogMessage("[[START]] Friendly units remaining: "..GetAllHeroes().count)
    

    --[[if(roomsCleared <= 1) then
        DCEI.ShowObjective("When a unit has a yellow ring around it, that means they can use their special ability!\n\nClick on a unit with a yellow ring to activate their special ability.")
        DCEI.Wait(6)
        DCEI.HideObjective()
    end]]
    ApplyBattlePerks()
    DCEI.LogMessage("Battle started! -- Postcall4.")
    if(roomsCleared == 0) then
        DCEI.LogMessage("Displaying OBS Help soon!")
        DCEI.Wait(11)
        
        
            DCEI.ShowMessageWithButtonText("Potions", "While in combat, you can use certain items to influence the battle. Try using a health potion to heal your hero!", "Okay!")
            AddItem("Health Potion", 1)
            local helper = NewBigHand(84,50,{parent = inventoryButton[1], anchor_right = true})
            while(targetingModeActive == false) do
                DCEI.SetUpdateFrequency(0.025)
                DCEI.Wait(0)
            end
            helper.Destroy()
            DCEI.SetUpdateFrequency(1)
            DCEI.Wait(5)
            DCEI.ShowMessageWithButtonText("Potions", "Here's a <color=yellow>Bomb Brew</color> potion, use it to instantly deal damage to enemies.", "Okay!")
            helper = NewBigHand(84,50,{parent = inventoryButton[1], anchor_right = true})
            DCEI.ShowMessageWithButtonText("Potions", "You'll be able to purchase additional potions in Shop rooms, and potions may also drop after defeating enemies.", "Okay!")
            AddItem("Bomb Brew", 1)
            while(targetingModeActive == false) do
                DCEI.SetUpdateFrequency(0.05)
                DCEI.Wait(0)
            end
            DCEI.SetUpdateFrequency(1)
            helper.Destroy()
        
    end
    UpdateTargetableHeroes()
    DCEI.LogMessage("Battle started! -- Postcall5.")
    DCEI.LogMessage("Battle started! -- Postcall6.")
    
    --DCEI.Wait(0)
    
    --DCEI.Wait(0.25)
    --UpdateActiveAffinities()
    --DCEI.Wait(0.25)
    --ExecuteAfter(UpdateActiveAffinities,0.25)
    
    
end

local finished = false
function OnBattleFinished(win)
    if(finished == true) then return end
    isEncounterActive = false
    battleOngoing = false
    finished = true
    lastStandActive = false
    campfireActive = false
    doublePower = false
    ClearTooltips()
    PauseAllUnits()
    ClearInspectDialog()
    UpdateInventoryUI()
    if(targetingModeActive) then
        ClearTargetingMode()
    end
    if(win == true) then
        if(willBeAmbushed == false) then
            roomsCleared = roomsCleared + 1
            roomsClearedThisFloor = roomsClearedThisFloor + 1
        end
        willBeAmbushed = false
        if(roomsCleared == 1) then
            if(settings.helpTips == true) then
                --DCEI.ShowMessageWithButtonText("Team Experience", "Whenever a hero has their ability ready, they will periodically generate <color=purple>team experience.</color>\n\nOnce your team reaches 100% team experience, you will gain a free perk which will increase the strength of your team for the rest of the run!", "Got it!")  
            end
        end
        for partyID = 1, PARTY_SIZE do
            if(party[partyID] ~= nil) then
                partyUnitHealth[partyID] = DCEI.GetHealthValue(party[partyID])
            end
            
            
        end
        DCEI.ShowSlowMotionEffect()
        DCEI.Wait(1)
        DCEI.ShowFeedbackMessage("<size=45>Victory!")
        PlaySound("[Sound] Battle Won")
        DCEI.Wait(1)
        
        local threatIncrease = 1 + currentFloor + roomDifficulty[currentRoom]
        IncreasePlayerThreat(threatIncrease)
        --ShowRelevantText("<color=red>++ "..threatIncrease.."% Threat")
        
        DCEI.Wait(3)
        if(roomsCleared == 1 and win == true) then
            
            DCEI.ShowMessageWithButtonText("Threat", "As you defeat enemies, you will accumulate <color=red>Threat.</color> As your Threat increases, combat encounters will become more difficult. Your party also has a chance to be ambushed based on your current Threat level.", "Next") 
            DCEI.ShowMessageWithButtonText("Threat", "Your Threat is reduced when you move to a new floor, and by certain events and items. Look for opportunities to reduce Threat where necessary!", "Got it!")
            
        end

        if(roomsCleared == 3 and win == true) then
            DCEI.ShowMessageWithButtonText("Hero Affinities", "Each hero you pick has at least one <color=yellow>Affinity.</color> This represents a type of unit. Having units of similar affinities in your party grants your team bonus effects based on the affinity.", "Next")
            DCEI.ShowMessageWithButtonText("Hero Affinities", "On the left side of the screen, you can view which affinities your team has, and which affinities are granting bonuses.", "Next")
            DCEI.ShowMessageWithButtonText("Hero Affinities", "If the icon is gray, that means you do not have the required number of heroes to meet that affinity's bonus requirements. If the icon is in color, you are currently receiving that affinity's bonus.", "Next")
            DCEI.ShowMessageWithButtonText("Party Tips", "As you pick heroes, try to pick heroes that have similar affinities to your current party. This will drastically increase your team's strength over time.", "Got it!")
        end
        if(CheckVictory() == true) then
            OnObjectivesComplete()
            ClearAllUnits()
            ClearInspectDialog()
            --DCEI.SetVictory()
        else
            local loot = GetLoot(currentDungeonLevel)
            eliteFight = false
            if(roomsCleared == 1) then
                --CreateInventoryFrame()
            end
            CreateLootDialog(loot, function()
                ClearAllUnits()
                ClearInspectDialog()
                table.insert( clearedRooms, currentRoom)
                IncreaseDungeonLevel()
                
                local wasHeroChoice = HandleHeroChoice()
                if(wasHeroChoice == false) then
                    OnHeroChoiceMadeOrSkipped()
                end
            --
                DCEI.HideSlowMotionEffect()
                UpdateInventoryUI()
            
            end)
            --DCEI.LogMessage("Created loot dialog.")
            DCEI.Wait(1)
            
        end
       
        
    else
        DCEI.ShowFeedbackMessage("Defeat!")
        DCEI.Save.Set("LastOutcome", "Defeat")
        DCEI.Save.Commit()
        DCEI.Wait(4)
        DCEI.PlayLevel("ProjectCalicoHub","Outpost")
        --DCEI.SetDefeat()
    end
    
    
end

function OnCheatEntered(message)
    if(message == "nightmare") then
        HandleNightmareUpdate()
        UpdateMapPanel()
    end
    if(message == "reveal") then
        ExecuteCampsiteDecision(3)
        UpdateMapPanel()
    end

    
    if(message == "instawin") then
        Cheat_InstaWin()
    end
    if(message == "instaloss") then
        Cheat_InstaLoss()
    end
    if(message == "makeharder") then
        IncreaseDungeonLevel()
        IncreaseDungeonLevel()
        IncreaseDungeonLevel()
        IncreaseDungeonLevel()
        IncreaseDungeonLevel()
        IncreaseDungeonLevel()
    end
    if(message == "makemuchharder") then
        for index=1,12 do
            IncreaseDungeonLevel()
        end
    end
    if(message == "kill1") then
        partyUnitHealth[1] = 0

    end
    if(message == "gimmegrit") then
        forcedPerkOffering = gamePerks[14]
    end 
    if(message == "updateaffin") then
        UpdateActiveAffinities()
    end 
    
end

function Cheat_InstaWin()
    OnObjectivesComplete()
    ClearAllUnits()
    ClearInspectDialog()
end

function Cheat_InstaLoss()
    DCEI.ShowFeedbackMessage("Defeat!")
    DCEI.Save.Set("LastOutcome", "Defeat")
    DCEI.Save.Commit()
    DCEI.Wait(4)
    DCEI.PlayLevel("ProjectCalicoHub","Outpost")
end

local objectivesComplete = false
function OnObjectivesComplete()
    DCEI.ShowFeedbackMessage("Run complete!")
    PlaySound("[Sound] Run Succeeded")
    DCEI.Wait(3)
    ConfirmDialog("Run Complete!","You've completed all objectives for this run! You can continue exploring, or return to town.","Return to Town","Continue Exploring", function()
        CompleteRun()
    end,function()
        CreateEndRunButton()
        OnShoppingEnded()
    end)

    objectivesComplete = true
    
end

function CompleteRun()
    DCEI.ShowFeedbackMessage("Run complete!")
    PlaySound("[Sound] Run Succeeded")
    DCEI.Save.Set("EarnedGold", playerGold)
    DCEI.Save.Set("LastOutcome", "Victory")
    DCEI.Save.Commit()
    DCEI.Wait(3)
    DCEI.PlayLevel("ProjectCalicoHub","Outpost")
end

function CheckVictory()
    --DCEI.LogMessage("CheckVictory() called.")
    if(objectivesComplete == true) then 
        --DCEI.LogMessage("CheckVictory() ignoring success- objectives already complete!")
        return false

    end
    if(questType == "Recruitment") then
        return (currentFloor >= currentDungeonFloors and (GetRoomTypeCount("Combat") <= 1 or GetClearedRoomsPercent() >= 80))
    elseif(questType == "Conquest") then
        return (currentFloor >= currentDungeonFloors and GetRoomTypeCount("Combat") == 0 and GetRoomTypeCount("Elite") == 0)
    elseif(questType == "Boss") then
        return (currentFloor >= currentDungeonFloors and GetRoomTypeCount("Boss") == 0)
    else
        return (currentFloor >= currentDungeonFloors and GetRoomTypeCount("Combat") == 0 and GetRoomTypeCount("Elite") == 0 and GetRoomTypeCount("Boss") == 0)
    end
    
    return false
end


function HandleHeroChoice()
    local heroChoiceThisLevel = false
    for index = 1, GetTableSize(HERO_CHOICE_LEVELS) do
        if((HERO_CHOICE_LEVELS[index] == roomsCleared or earnsHeroThisLevel) and PARTY_SIZE < 8) then
            heroChoiceThisLevel = true
            earnsHeroThisLevel = false
            PresentHeroChoice(GetRandomChoosableHeroes(),
            function()
                OnHeroChoiceMadeOrSkipped()
            end
        )
        end
    end
    return heroChoiceThisLevel
end

function OnShoppingEnded()
    if(CheckVictory() == true) then
        OnObjectivesComplete()
        ClearAllUnits()
        ClearInspectDialog()
    else
        IncreaseDungeonLevel()
        table.insert( clearedRooms, currentRoom)
        ClearInspectDialog()
        OnHeroChoiceMadeOrSkipped()
    end
    
end

function OnHeroChoiceMadeOrSkipped()
    DCEI.LogMessage("Doing end of combat checks.")
    if(threatLevel >= 30 and roomsClearedThisFloor >= 4 and GetSpecialRoomCount() < 2) then
        local roomToConvert = GetRandomCombatRoom()
        DCEI.LogMessage("Attempting to convert combat room to special property:"..roomToConvert)
        if(roomToConvert >= 0 and specialRoomModifiers[roomToConvert] == "None") then
            specialRoomModifiers[roomToConvert] = GetRandomSpecialRoomModifier()
            DCEI.LogMessage("Attempting to convert combat room to special property:"..roomToConvert.." to type: "..specialRoomModifiers[roomToConvert])
        end
        ShowRelevantText("+ Threat Room!")
    end
    DCEI.Wait(1)
    UpdateMapPanel()
    
    ToggleMapFrame(true)
    
    HandleSpecialRoomEffects()
    if(threatLevel >= 100) then
        HandleNightmareUpdate()
    end
    
    earnsHeroThisLevel = false
    --DCEI.Wait(2)
    --DCEI.ShowFeedbackMessage("Choose a room to move to!")
    
end

function GetRandomChoosableHeroes()
    local possibleChoices = {}
    for index = 1, GetTableSize(HERO_TYPES) do
        if(PartyHasHero(HERO_TYPES[index]) == false or RandomChance(30)) then
            table.insert(possibleChoices, index) --Add every possible index as a potential choice.
        else
            DCEI.LogMessage("Will not add hero type: "..HERO_TYPES[index].name.." to the hero pool because the player already has a hero of that type!")
        end
        
    end
    local returnValue = {}
    for choiceIndex = 1, 2 do --Choose 3 heroes
        for tableIndex = 1, GetTableSize(possibleChoices) do --Choose 3 heroes
            local randomIndex = GetRandomIndex(possibleChoices)
            local randomChoice = possibleChoices[randomIndex] -- This is the index of the hero to choose from HERO_TYPES.
            --DCEI.LogMessage("Got RANDOM hero index: "..randomChoice)
            table.insert(returnValue, HERO_TYPES[randomChoice])
            table.remove( possibleChoices, randomIndex )

        end
    end
    table.insert(returnValue, nil)
    if(PARTY_SIZE == 0) then
        returnValue = {HERO_TYPES[3],nil,nil} --Berserker as first choice.
    elseif(PARTY_SIZE == 1) then
        returnValue = {HERO_TYPES[2],nil,nil} --Rifleman as 2nd choice.
    elseif(PARTY_SIZE == 2) then
        returnValue = {HERO_TYPES[3],nil,nil} --Berserker as first choice.
    elseif(PARTY_SIZE == 3) then
        returnValue = {HERO_TYPES[4],nil,nil} --Archer as next Choice
    elseif(PARTY_SIZE == 4) then
        returnValue = {HERO_TYPES[4],nil,nil} --Archer as next Choice
    end
    return returnValue
end

function GetAffinityByName(affinityName)
    local returnValue = nil
    foreach(AFFINITIES, function(affinity)
        if(affinity.name == affinityName) then returnValue = affinity end
        
    end)
    return returnValue
end

function GetRandomHeroesWithAffinity(affinityName)
    local possibleChoices = {}
    local affinity = GetAffinityByName(affinityName)
    DCEI.LogMessage("Got affinity:"..affinity.name.." from name: "..affinityName)
    for index = 1, GetTableSize(HERO_TYPES) do
        if(TableContains(HERO_TYPES[index].affinities,affinity) == true) then
            DCEI.LogMessage("Recognized hero:"..HERO_TYPES[index].name.." as hero with affinity: "..affinityName)
            table.insert(possibleChoices,index)
        end
        
    end
    local returnValue = {}
    for choiceIndex = 1, 3 do --Choose 3 heroes
        for tableIndex = 1, GetTableSize(possibleChoices) do --Choose 3 heroes
            local randomIndex = GetRandomIndex(possibleChoices)
            local randomChoice = possibleChoices[randomIndex] -- This is the index of the hero to choose from HERO_TYPES.
            --DCEI.LogMessage("Got RANDOM hero index: "..randomChoice)
            table.insert(returnValue, HERO_TYPES[randomChoice])
            table.remove( possibleChoices, randomIndex )

        end
    end
    return returnValue
end


function HandleRepositionMode()
    --DCEI.LogMessage("Handling reposition.")
    local mouseX = DCEI.GetMousePosition2D().x
    local mouseY = DCEI.GetMousePosition2D().y
    
    if(selectedUnit ~= nil) then
        local closestSnapPoint = GetClosestHexPointToPoint(DCEI.GetMousePosition2D(),true)
        --DCEI.LogMessage("Moving a selected unit to position: "..mouseX..","..mouseY)
        DCEI.SetUnitPosition2DWithInterpolation(selectedUnit, closestSnapPoint.x+snapOffset.x, closestSnapPoint.y+snapOffset.y)
        --hasRepositioned = true
        if(roomsCleared == 1) then
            --DCEI.SetActive(startCombatButton, true)
            --repositionModeActive = false
        end
    end
    DCEI.Wait(.001)
    if(repositionModeActive == true) then
        HandleRepositionMode()
    else
        OnRepositionModeEnd()
    end

end

function OnRepositionModeEnd()
    SetOccupiedHexPoints()
end

-- UI Functions
local root = DCEI.GetUiRoot()
local combatDialog = nil
local startCombatButton = nil
function CreateCombatDialog(allowReposition)
    local container = DCEI.NewFrame(root)
    combatDialog = container
    DCEI.SetBottomAlignmentInParent(container)
    DCEI.SetLeftAlignmentInParent(container)
    DCEI.SetHorizontalOffsetInParent(container, 15)
    DCEI.SetVerticalOffsetInParent(container, 15)

    local padding = DCEI.NewFrame(container)
    local abilityFrame = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(abilityFrame, "frame_slot00")
    DCEI.SetBackgroundImageColor(abilityFrame, 1, 1, 1, 0 / 255)
    DCEI.SetMinSize(abilityFrame, 325, 170)

    -- Start battle button
    local button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "startBattle_button")
    DCEI.SetLeftAlignmentInParent(button)
    DCEI.SetTopAlignmentInParent(button)
    DCEI.SetHorizontalOffsetInParent(button, 15)
    DCEI.SetVerticalOffsetInParent(button, -80)
    DCEI.SetMinSize(button, 100, 100)
    DCEI.SetMaxSize(button, 100, 100)
    startCombatButton = button
    local levelButtonText = DCEI.NewText(button)
    DCEI.SetText(levelButtonText, "<size=35>Start Battle")
    DCEI.SetHorizontalOffsetInParent(levelButtonText, 180)

    DCEI.SetOnClickCallback(button, 
    function()
        UnpauseAllUnits()
        DCEI.SetActive(container,false)
        OnBattleStarted()
        
    end)

    if(allowReposition == nil or allowReposition == true) then
        repositionModeActive = true
        HandleRepositionMode()
    end
    
    ClearInspectDialog()
    -- Reposition button
    --[[button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "icon_enhance_crusader_punish")
    DCEI.SetLeftAlignmentInParent(button)
    DCEI.SetTopAlignmentInParent(button)
    DCEI.SetHorizontalOffsetInParent(button, 15)
    DCEI.SetVerticalOffsetInParent(button, -94)
    DCEI.SetMinSize(button, 64, 64)
    DCEI.SetMaxSize(button, 64, 64)

    local levelButtonText = DCEI.NewText(button)
    DCEI.SetText(levelButtonText, "Reposition")
    DCEI.SetHorizontalOffsetInParent(levelButtonText, 150)

    DCEI.SetOnClickCallback(button, 
    function()
        ClearInspectDialog()
        repositionModeActive = true
        ToggleHexGrid(true)
        HandleRepositionMode()
    end)]]

    
    return {
        frame = container,
    }
end

function GetHeroIcon(partyMemberID)
    local returnValue = "question_green"
    foreach(HERO_TYPES, function(heroType)
        if(partyUnits[partyMemberID] == heroType.name) then
            returnValue = heroType.image
        end
    end)

    return returnValue
end



local choiceDialog = nil
function CreateThreeChoiceDialog(title, desc, choiceTexts, choiceTooltips, callbacks)
    if(choiceDialog ~= nil) then
        DCEI.LogMessage("Denied showing choice dialog box w/Title="..title.." because a confirm box is showing already!")
        return
    end
    local container = DCEI.NewFrame(root)
    choiceDialog = container
    local dialogX = 555
    local dialogY = 330
    local fontSize = 18
    local padding = DCEI.NewFrame(container)
    local background = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(background, "frame_slot00")
    DCEI.SetBackgroundImageColor(background, 1, 1, 1, 255)
    DCEI.SetMinSize(background, dialogX, dialogY)
    DCEI.SetMaxSize(background, dialogX, dialogY)

    local titleText = DCEI.NewText(padding)
    DCEI.SetText(titleText, "<color=yellow>"..title)
    DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -15)

    titleText = DCEI.NewText(padding)
    DCEI.SetText(titleText, desc)
    DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -55)
    DCEI.SetMaxSize(titleText, dialogX-25, dialogY-100)
    DCEI.SetTextFontSize(titleText,18)
    
    local button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "btn_blue2")
    DCEI.SetBottomAlignmentInParent(button)
    DCEI.SetVerticalOffsetInParent(button, 15+50+50+20)
    DCEI.SetMinSize(button, dialogX-25, 50)
    DCEI.SetMaxSize(button, dialogX-25, 50)
    DCEI.SetTooltipText(button, choiceTooltips[1])
    local buttonText = DCEI.NewText(button)
    DCEI.SetText(buttonText, choiceTexts[1])
    DCEI.SetMaxSize(buttonText, dialogX-30, 45)
    DCEI.SetTextFontSize(buttonText,fontSize)
    DCEI.SetOnClickCallback(button, 
    function()
        DCEI.Destroy(container)
        callbacks[1]()
        
        choiceDialog = nil
    end)

    button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "btn_purple_light")
    DCEI.SetBottomAlignmentInParent(button)
    DCEI.SetVerticalOffsetInParent(button, 15+50+12)
    DCEI.SetMinSize(button, dialogX-25, 50)
    DCEI.SetMaxSize(button, dialogX-25, 50)
    DCEI.SetTooltipText(button, choiceTooltips[2])
    buttonText = DCEI.NewText(button)
    DCEI.SetText(buttonText, choiceTexts[2])
    DCEI.SetMaxSize(buttonText, dialogX-30, 45)
    DCEI.SetTextFontSize(buttonText,fontSize)
    DCEI.SetOnClickCallback(button, 
    function()
        DCEI.Destroy(container)
        callbacks[2]()
        
        choiceDialog = nil
    end)

    button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "btn_purple")
    DCEI.SetBottomAlignmentInParent(button)
    DCEI.SetVerticalOffsetInParent(button, 20)
    DCEI.SetMinSize(button, dialogX-25, 50)
    DCEI.SetMaxSize(button, dialogX-25, 50)
    DCEI.SetTooltipText(button, choiceTooltips[3])
    buttonText = DCEI.NewText(button)
    DCEI.SetText(buttonText, choiceTexts[3])
    DCEI.SetMaxSize(buttonText, dialogX-30, 45)
    DCEI.SetTextFontSize(buttonText,fontSize)
    DCEI.SetOnClickCallback(button, 
    function()
        DCEI.Destroy(container)
        callbacks[3]()
        
        choiceDialog = nil
    end)

end


local confirmDialogBox = nil
function ConfirmDialog(confirmTitle, confirmDesc, confirmButtonText,denyButtonText, onConfirmCallback,onDenyCallback)
    if(confirmDialogBox ~= nil) then
        DCEI.LogMessage("Denied showing confirm dialog box w/Title="..confirmTitle.." because a confirm box is showing already!")
        return
    end
    if(confirmTitle == nil) then
        confirmTitle = "Confirm?"
    end
    if(confirmDesc == nil) then
        confirmDesc = "Are you sure?"
    end
    if(confirmButtonText == nil) then
        confirmButtonText = "Confirm"
    end
    if(denyButtonText == nil) then
        denyButtonText = "Cancel"
    end
    local container = DCEI.NewFrame(root)
    confirmDialogBox = container
    local dialogX = 425
    local dialogY = 280
    local padding = DCEI.NewFrame(container)
    local background = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(background, "frame_slot00")
    DCEI.SetBackgroundImageColor(background, 1, 1, 1, 255)
    DCEI.SetMinSize(background, dialogX, dialogY)
    DCEI.SetMaxSize(background, dialogX, dialogY)

    local titleText = DCEI.NewText(padding)
    DCEI.SetText(titleText, "<color=yellow>"..confirmTitle)
    DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -15)

    titleText = DCEI.NewText(padding)
    DCEI.SetText(titleText, confirmDesc)
    DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -55)
    DCEI.SetMaxSize(titleText, dialogX-25, dialogY-100)
    DCEI.SetTextFontSize(titleText,18)
    
    local button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "btn_blue2")
    DCEI.SetBottomAlignmentInParent(button)
    DCEI.SetVerticalOffsetInParent(button, 15+50+20)
    DCEI.SetMinSize(button, dialogX-25, 50)
    DCEI.SetMaxSize(button, dialogX-25, 50)
    local buttonText = DCEI.NewText(button)
    DCEI.SetText(buttonText, confirmButtonText)
    DCEI.SetOnClickCallback(button, 
    function()
        DCEI.Destroy(container)
        confirmDialogBox = nil
        onConfirmCallback()
        
    end)

    button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "btn_red")
    DCEI.SetBottomAlignmentInParent(button)
    DCEI.SetVerticalOffsetInParent(button, 20)
    DCEI.SetMinSize(button, dialogX-25, 50)
    DCEI.SetMaxSize(button, dialogX-25, 50)
    buttonText = DCEI.NewText(button)
    DCEI.SetText(buttonText, denyButtonText)
    DCEI.SetOnClickCallback(button, 
    function()
        DCEI.Destroy(container)
        confirmDialogBox = nil
        onDenyCallback()
        
    end)

end

local affinityDialogFrame = nil
function CreateAffinityFrame()
    local container = DCEI.NewFrame(root)    
    DCEI.SetLeftAlignmentInParent(container)
    affinityDialogFrame = container
    --DCEI.SetHorizontalOffsetInParent(container, 15)
    --DCEI.SetVerticalOffsetInParent(container, -5)

    local padding = DCEI.NewFrame(container)
    local affinityFrame = DCEI.NewVStack(padding)
    
    DCEI.SetBackgroundImage(affinityFrame, "frame_slot00")
    DCEI.SetBackgroundImageColor(affinityFrame, 246, 225, 87, 0 / 255)
    DCEI.SetSize(affinityFrame, 50, 425)
    DCEI.SetSpacing(affinityFrame,0)
    DCEI.SetPadding(affinityFrame, 15)

    local affinityFrameAlternate = DCEI.NewVStack(padding)
    DCEI.SetBackgroundImage(affinityFrameAlternate, "frame_slot00")
    DCEI.SetBackgroundImageColor(affinityFrameAlternate, 246, 225, 87, 0 / 255)
    DCEI.SetSize(affinityFrameAlternate, 50, 425)
    DCEI.SetSpacing(affinityFrameAlternate,0)
    DCEI.SetPadding(affinityFrameAlternate, 15)
    DCEI.SetHorizontalOffsetInParent(affinityFrameAlternate,35)

    local id = 0
    --DCEI.LogMessage("Got Affinity count: "..GetTableSize(AFFINITIES))
    foreach(AFFINITIES, function(affinity)
        if(roomsCleared < 2) then

        else
            if(affinity.isActive ~= nil and affinity.isActive) then
            local affinityButton = nil
            local tooltipText = HighlightKeywords(affinity.passiveDescription..GetAffinityBonusDescriptionText(affinity))
            if(id % 2 == 0) then
                affinityButton = DCEI.NewFrame(affinityFrame)
                affinity.button = affinityButton
                DCEI.SetBackgroundImage(affinityButton,affinity.image)
                DCEI.SetSize(affinityButton,50,47)
                DCEI.SetHorizontalOffsetInParent(affinityButton,250)
                DCEI.SetBackgroundImageGrayScale(affinityButton,true)
                DCEI.SetTooltipText(affinityButton,tooltipText)
    
                local invisbutton = DCEI.NewFrame(affinityFrameAlternate)
                DCEI.SetBackgroundImage(invisbutton,affinity.image)
                DCEI.SetBackgroundImageColor(invisbutton,0,0,0,0)
                DCEI.SetSize(invisbutton,50,47)
                DCEI.SetHorizontalOffsetInParent(invisbutton,250)
                DCEI.SetBackgroundImageGrayScale(invisbutton,true)
            else
                affinityButton = DCEI.NewFrame(affinityFrameAlternate)
                affinity.button = affinityButton
                DCEI.SetBackgroundImage(affinityButton,affinity.image)
                DCEI.SetSize(affinityButton,50,47)
                DCEI.SetTooltipText(affinityButton,tooltipText)
                DCEI.SetHorizontalOffsetInParent(affinityButton,250)
                --DCEI.SetBackgroundImageGrayScale(affinityButton,true)
    
                local invisbutton = DCEI.NewFrame(affinityFrame)
                DCEI.SetBackgroundImage(invisbutton,affinity.image)
                DCEI.SetBackgroundImageColor(invisbutton,0,0,0,0)
                DCEI.SetSize(invisbutton,50,47)
                DCEI.SetHorizontalOffsetInParent(invisbutton,250)
                DCEI.SetBackgroundImageGrayScale(invisbutton,true)
            end
    
            local afinText = DCEI.NewText(affinityButton)
            DCEI.SetSize(afinText,45,15)
            --DCEI.SetRightAlignmentInParent(afinText)
            DCEI.SetBottomAlignmentInParent(afinText)
            DCEI.SetTextFontSize(afinText,15)
            DCEI.SetText(afinText,"3")
            --DCEI.SetHorizontalOffsetInParent(afinText,-6)
            DCEI.SetVerticalOffsetInParent(afinText,-2)
            affinity.countText = afinText
    
            local affinCount = GetAffinityCount(affinity)
            if(affinity.bonusActive == true) then
                DCEI.SetBackgroundImageGrayScale(affinityButton,false)
                DCEI.SetBackgroundImageColor(affinityButton,1,1,1,225/255)
                DCEI.SetTooltipText(affinityButton,tooltipText)
                DCEI.SetText(affinity.countText,GetAffinCountText(affinCount,affinity))
            elseif(affinity.name ~= "Bonus" and affinity.name ~= "Nightmare") then
                DCEI.SetBackgroundImageGrayScale(affinityButton,true)
                DCEI.SetBackgroundImageColor(affinityButton,1,1,1,140/255)
                DCEI.SetTooltipText(affinityButton,tooltipText)
                DCEI.SetText(affinity.countText,GetAffinCountText(affinCount,affinity))
            
            else
                --Bonus Affinity
                DCEI.SetBackgroundImageGrayScale(affinityButton, affinCount == 0)
                DCEI.SetBackgroundImageColor(affinityButton,1,1,1,225/255)
                DCEI.SetTooltipText(affinityButton,HighlightKeywords(affinity.passiveDescription))
                DCEI.SetText(affinity.countText,affinCount)
                DCEI.SetTextFontSize(affinity.countText, 19)
            end
            
    
            
            id = id + 1
        end
    end

        
    end)

    function GetAffinityBonusDescriptionText(affinity)
        local bonusEffectText = "<color=#ffff80>AFFINITY BONUS</color>\n"
        local pluralText = "s"
        if(affinity.requiredCount == 1) then
            pluralText = ""
        end
        local text = bonusEffectText.."<color=#d9d9d9><size=12>*REQUIRES "..affinity.requiredCount.."+ "..affinity.name.." unit"..pluralText.."*</size></color>\n"
        if(affinity.requireExactCount) then
            text = bonusEffectText.."<color=#d9d9d9><size=12>*REQUIRES (Exactly) "..affinity.requiredCount.." "..affinity.name.." unit"..pluralText.."*</size></color>\n"
        end
        return "\n______________\n"..text.."\n"..affinity.description
    end

    function GetAffinCountText(count,affinity)
        local pretext = " "
        local maxText = affinity.requiredCount.."+"
        if(affinity.requireExactCount) then
            maxText = affinity.requiredCount
            pretext = ""
        end
        return pretext..count.."/"..maxText
    end
    
    -- Inventory Buttons
    --[[local BUTTON_X = 60
    local BUTTON_Y = 60
    local OFFSET = 15
    
    for inventoryID = 1, BUTTON_COUNT do
        
        inventoryButton[inventoryID] = DCEI.NewButton(container)
        local button = inventoryButton[inventoryID]
        local xPos = OFFSET + ((OFFSET + BUTTON_X) * (inventoryID-1))
        --DCEI.LogMessage("Creating Inventory Button: "..inventoryID.." at xPos: "..xPos)
        DCEI.SetBackgroundImage(button, "icon_enhance_cannontower_spikebomb")
        DCEI.SetLeftAlignmentInParent(button)
        DCEI.SetHorizontalOffsetInParent(button, xPos)
        DCEI.SetVerticalOffsetInParent(button, -15)
        DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
        DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)
        DCEI.EnableButton(button, false)

        inventoryChargeText[inventoryID] = DCEI.NewText(button)
        local levelButtonText = inventoryChargeText[inventoryID]
        DCEI.SetText(levelButtonText, "0")
        DCEI.SetHorizontalOffsetInParent(levelButtonText, 20)
        DCEI.SetVerticalOffsetInParent(levelButtonText, -15)
        DCEI.SetTextFontSize(levelButtonText, 30)
        
        DCEI.SetOnClickCallback(inventoryButton[inventoryID], 
        function()
            OnItemSelected(inventoryID)
        end)
        
    end]]

end

function OnItemSelected(slot)
    DCEI.LogMessage("OnItemSelected called for slot: "..slot)
    local itemInSlot = inventory[slot]
    if(itemInSlot ~= nil) then
        if(itemInSlot.flags ~= nil and (itemInSlot.flags.treasureItem == true or itemInSlot.flags.hasTarget == false)) then
            HandleItemUse(itemInSlot.name)
        else
            
            ExpectTarget(ITEM_CASTER,itemInSlot.name)
        end
        
        --[[DCEI.EnterTargetingMode(ITEM_CASTER, itemInSlot.name)
        targetingModeActive = true]]
    elseif(slot > 0) then
        DCEI.LogMessage("WARNING -- Got null item in slot: "..slot)
    end
end

function HandleItemUse(itemName)
    if(battleOngoing == true or isEncounterActive or nightmareUpdating == true or mapFrameVisible == false or lootDialogShown == true or isChoosingPerk == true) then
        ShowErrorText("You can't do that now!")
        return
    end
    if(itemName == "Omnistone") then
        GiveFreePerk(Clamp(1+currentFloor,1,4))
    elseif(itemName == "Seer's Eye") then
        ExecuteCampsiteDecision(3)
    elseif(string.match(itemName, "Affinity Tome: ")) then
        local affinityToBuffName = string.gsub( itemName,"Affinity Tome: ","")
        DCEI.LogMessage("Got Affinity Tome use:"..affinityToBuffName)
        ShowRelevantText("+ 1 "..affinityToBuffName.." Affinity")
        table.insert(affinityTokens,affinityToBuffName)
        UpdateActiveAffinities()
    else
        ShowErrorText("You can't use that item!")
    end
    OnItemUsed(itemName)
end

function OnItemUsed(itemName)
    for inventoryID = 1, BUTTON_COUNT do
        local itemInSlot = inventory[inventoryID]
        if(itemInSlot ~= nil and itemInSlot.name == itemName) then
            --DCEI.LogMessage("OnItemUsed called for slot: "..inventoryID.." with item name: "..itemName)
            inventory[inventoryID].count = itemInSlot.count - 1
            if(inventory[inventoryID].count <= 0) then
                inventory[inventoryID] = nil
            end
            
        end
        
        
    end
    UpdateInventoryUI()
end

function GetEmptyInventorySlot()
    for inventoryID = 1, BUTTON_COUNT do
        if(inventory[inventoryID] == nil) then
            return inventoryID
        end
    end
    return -1
end

function IsInventoryFull()
    return GetEmptyInventorySlot() == -1
end

function PlayerHasItemName(itemName)
    for inventoryID = 1, BUTTON_COUNT do
        local itemInSlot = inventory[inventoryID]
        if(itemInSlot ~= nil and itemInSlot.name == itemName) then
            return true
        end
        
        
    end
    return false
end

function GetItemByName(itemName)
    local returnItem = nil
    foreach(shopItems,function(item)
        if(item.name == itemName) then
            returnItem = item
        end
    
    end)
    --DCEI.LogMessage("Got item :"..(returnItem.name).." from name:"..itemName.." w/TT="..returnItem.tooltip)
    --Item("Bomb Brew","Deal 35 damage to all enemies in a target area.",1,"icon_enhance_scorcher_living_bomb",5),
    return deepcopy(returnItem)
end

function AddItem(itemName, countToAdd)
    if(IsInventoryFull() == true and PlayerHasItemName(itemName) == false) then
        ShowErrorText("Inventory full!")
        return
    end
    --DCEI.LogMessage("Attemptingto add item to inv:"..itemName.." x"..countToAdd)
    if(PlayerHasItemName(itemName) == false) then
        local slot = GetEmptyInventorySlot()
        --DCEI.LogMessage("Got Empty slot: "..slot)
        inventory[slot] = GetItemByName(itemName)
        inventory[slot].count = countToAdd
        --DCEI.LogMessage("Got new count of added item: "..inventory[slot].count)
    else
        --DCEI.LogMessage("Player already has item: "..itemName)
        for inventoryID = 1, BUTTON_COUNT do
            local itemInSlot = inventory[inventoryID]
            if(itemInSlot ~= nil and itemInSlot.name == itemName) then
                --DCEI.LogMessage("OnItemUsed called for slot: "..inventoryID.." with item name: "..itemName)
                --DCEI.LogMessage("Got existing count of item: "..itemInSlot.count.." and count to add:"..countToAdd)
                --DCEI.LogMessage("Got existing item name: "..(inventory[inventoryID].name))
                inventory[inventoryID].count = itemInSlot.count + countToAdd
                --DCEI.LogMessage("Got new count of added item: "..inventory[inventoryID].count)
            end
        end
        
    end
    
    UpdateInventoryUI()
end


function CreateInventoryFrame()
    local container = DCEI.NewFrame(root)
    
    DCEI.SetBottomAlignmentInParent(container)
    --DCEI.SetLeftAlignmentInParent(container)
    DCEI.SetHorizontalOffsetInParent(container, 15)
    DCEI.SetVerticalOffsetInParent(container, -5)

    local padding = DCEI.NewFrame(container)
    local abilityFrame = DCEI.NewFrame(padding)
    inventoryDialog = abilityFrame
    DCEI.SetBackgroundImage(abilityFrame, "frame_slot00")
    DCEI.SetBackgroundImageColor(abilityFrame, 246, 225, 87, 255 / 255)
    DCEI.SetMinSize(abilityFrame, 540, 125)
    --local inventoryText = DCEI.NewText(abilityFrame)
    --DCEI.SetText(inventoryText, "Inventory")
    --DCEI.SetTopAlignmentInParent(inventoryText)
    --DCEI.SetVerticalOffsetInParent(inventoryText, 30)
    --DCEI.SetTextFontSize(inventoryText, 25)

    -- Inventory Buttons
    local BUTTON_X = 60
    local BUTTON_Y = 60
    local OFFSET = 15
    
    for inventoryID = 1, BUTTON_COUNT do
        
        inventoryButton[inventoryID] = DCEI.NewButton(container)
        local button = inventoryButton[inventoryID]
        local xPos = OFFSET + ((OFFSET + BUTTON_X) * (inventoryID-1))
        DCEI.SetBackgroundImage(button, "icon_enhance_cannontower_spikebomb")
        DCEI.SetLeftAlignmentInParent(button)
        DCEI.SetHorizontalOffsetInParent(button, xPos)
        DCEI.SetVerticalOffsetInParent(button, -15)
        DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
        DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)
        DCEI.EnableButton(button, false)

        local discardButton = DCEI.NewButton(button)
        inventoryDiscardButton[inventoryID] = discardButton
        DCEI.SetBackgroundImage(discardButton, "btn_close")
        DCEI.SetBackgroundImageColor(discardButton,252/255,93/255,93/255,1)
        DCEI.SetTopAlignmentInParent(discardButton)
        DCEI.SetRightAlignmentInParent(discardButton)
        DCEI.SetHorizontalOffsetInParent(discardButton,15)
        DCEI.SetVerticalOffsetInParent(discardButton,15)
        DCEI.SetSize(discardButton,20,20)
        DCEI.SetTooltipText(discardButton,"Click to discard this item.")

        DCEI.SetOnClickCallback(inventoryDiscardButton[inventoryID], 
        function()
            DiscardItem(inventoryID)
        end)

        inventoryChargeText[inventoryID] = DCEI.NewText(button)
        local levelButtonText = inventoryChargeText[inventoryID]
        DCEI.SetText(levelButtonText, "0")
        DCEI.SetHorizontalOffsetInParent(levelButtonText, 20)
        DCEI.SetVerticalOffsetInParent(levelButtonText, -15)
        DCEI.SetTextFontSize(levelButtonText, 30)
        
        DCEI.SetOnClickCallback(inventoryButton[inventoryID], 
        function()
            OnItemSelected(inventoryID)
        end)
        
    end

    function UpdateInventoryUI()
        for inventoryID = 1, BUTTON_COUNT do
            local itemInSlot = inventory[inventoryID]
            local button = inventoryButton[inventoryID]
            if(itemInSlot ~= nil) then
                
                DCEI.SetBackgroundImage(button, itemInSlot.image)
                DCEI.SetText(inventoryChargeText[inventoryID], itemInSlot.count)
                DCEI.SetTooltipText(button,GetItemTooltip(itemInSlot))
                if(itemInSlot.count > 0) then
                    DCEI.EnableButton(button, true)
                    if(battleOngoing == false) then
                        DCEI.SetActive(inventoryDiscardButton[inventoryID], true)
                    else
                        DCEI.SetActive(inventoryDiscardButton[inventoryID], false)
                    end
                    
                else
                    DCEI.EnableButton(button, false)
                    DCEI.SetActive(inventoryDiscardButton[inventoryID], false)
                end

            else
                DCEI.EnableButton(button, false)
                DCEI.SetActive(inventoryDiscardButton[inventoryID], false)
                --DCEI.EnableButton()
                DCEI.SetTooltipText(button,"")
                DCEI.SetText(inventoryChargeText[inventoryID], "")
            end
            
            
        end
    end


    
--[[
    -- Reposition button
    button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "icon_enhance_crusader_punish")
    DCEI.SetLeftAlignmentInParent(button)
    DCEI.SetTopAlignmentInParent(button)
    DCEI.SetHorizontalOffsetInParent(button, 15)
    DCEI.SetVerticalOffsetInParent(button, -94)
    DCEI.SetMinSize(button, 64, 64)
    DCEI.SetMaxSize(button, 64, 64)

    local levelButtonText = DCEI.NewText(button)
    DCEI.SetText(levelButtonText, "Reposition")
    DCEI.SetHorizontalOffsetInParent(levelButtonText, 150)

    DCEI.SetOnClickCallback(button, 
    function()
        
    end)]]

    
    return {
        frame = container,
    }
end

function GetItemTooltip(item)
    local completeItem = GetItemByName(item.name)
    --DCEI.LogMessage("Got tooltip of item: "..completeItem.name.." as: "..completeItem.tooltip)
    return completeItem.tooltip
end

function ClaimItem(lootItem)
    if(lootItem.name == "Gold") then
        playerGold = playerGold + lootItem.count
        UpdateGoldPanel()
        return
    end
    if(lootItem.name == "Perk") then
        
    else 
        
        AddItem(lootItem.name, lootItem.count)
    end
    
end

function DiscardItem(slotID)
    ShowRelevantText("<color=orange>Discarded!")
    inventory[slotID] = nil
    UpdateInventoryUI()
end

function GetTeamScore()
    if(PARTY_SIZE == 0) then return 0 end
    local returnScore = PARTY_SIZE * (100)
    foreach(partyUnitHealth, function(healthValue)
        if(healthValue ~= nil) then
            returnScore = returnScore + healthValue
        end
        
    end)
    returnScore = math.ceil(returnScore + (currentDungeonLevel * 4) + (GetTableSize(playerPerks) * 75))
    return returnScore
end

local teamViewDialog = nil
local firstCreation = true
function CreateTeamViewDialog(showOnCreate)
    
    local container = DCEI.NewFrame(root)
    local openButton = DCEI.NewButton(inventoryDialog)
    local padding = DCEI.NewFrame(container)
    local background = DCEI.NewFrame(padding)
    local closeButton = DCEI.NewButton(padding)
    teamViewDialog = {container}
    teamViewDialog.SetActive = function(state)
        DCEI.SetActive(container,state)
        DCEI.SetActive(openButton, not state)
    end

    
    DCEI.SetBackgroundImage(openButton, "btn_yellow")
    DCEI.SetMinSize(openButton, 110, 60)
    DCEI.SetMaxSize(openButton, 110, 60)
    --DCEI.SetTopAlignmentInParent(openButton)
    DCEI.SetRightAlignmentInParent(openButton)
    DCEI.SetHorizontalOffsetInParent(openButton, 120)
    DCEI.SetVerticalOffsetInParent(openButton, -25)
    if(firstCreation == false) then
        DCEI.SetActive(openButton,false)
    end
    firstCreation = false
    DCEI.SetOnClickCallback(openButton, function()
        DCEI.Destroy(teamViewDialog)
        DCEI.Destroy(openButton)
        CreateTeamViewDialog(true)
    end)

    local openButtonText = DCEI.NewText(openButton)
    DCEI.SetText(openButtonText, "".."Team Summary")
    --DCEI.SetTopAlignmentInParent(openButtonText)
    --DCEI.SetVerticalOffsetInParent(openButtonText, -25)
    DCEI.SetTextFontSize(openButtonText,17)
    DCEI.SetMaxSize(openButtonText,105,55)

    
    local dialogX = 750
    local dialogY = 400
    local fontSize = 20
    
    
    DCEI.SetBackgroundImage(background, "frame_dark_stroke")
    DCEI.SetBackgroundImageColor(background, 1, 1, 1, 255)
    DCEI.SetMinSize(background, dialogX, dialogY)
    DCEI.SetMaxSize(background, dialogX, dialogY)

    local header = DCEI.NewFrame(background)
    DCEI.SetBackgroundImage(header, "frame_half_top_blue")
    DCEI.SetMinSize(header, dialogX-5, 70)
    DCEI.SetMaxSize(header, dialogX-5, 70)
    DCEI.SetTopAlignmentInParent(header)
    DCEI.SetVerticalOffsetInParent(header,-4)

    DCEI.SetBackgroundImage(closeButton, "btn_close")
    DCEI.SetMinSize(closeButton, 40, 40)
    DCEI.SetMaxSize(closeButton, 40, 40)
    DCEI.SetTopAlignmentInParent(closeButton)
    DCEI.SetRightAlignmentInParent(closeButton)
    DCEI.SetOnClickCallback(closeButton, function()
        teamViewDialog.SetActive(false)
    end)

    local titleText = DCEI.NewText(padding)
    DCEI.SetText(titleText, "<color=yellow>".."Team Summary")
    DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -25)
    DCEI.SetTextFontSize(titleText,30)

    
    

    local heroIconX = 55
    local heroIconY = 55
    local spacing = 35
    local stack = DCEI.NewHStack(padding)
    DCEI.SetBackgroundImage(stack, "frame_slot00")
    DCEI.SetBackgroundImageColor(stack, 1, 1, 1, 10/255)
    DCEI.SetMinSize(stack, dialogX-25, heroIconY + 25)
    DCEI.SetMaxSize(stack, dialogX-25, heroIconY + 25)
    DCEI.SetTopAlignmentInParent(stack)
    DCEI.SetVerticalOffsetInParent(stack,-90)
    DCEI.SetSpacing(stack,spacing)
    DCEI.SetPadding(stack, 15)


    local spacing = 35
    local perkFrame = {}
    perkFrame.background = DCEI.NewFrame(padding)
    perkFrame.parent = DCEI.NewVScroll(perkFrame.background)
    perkFrame.container = DCEI.GetScrollContent(perkFrame.parent)

    DCEI.SetBackgroundImage(perkFrame.parent, "frame_thick_dark_grey")
    DCEI.SetBackgroundImageColor(perkFrame.parent, 1, 1, 1, 255/255)
    --DCEI.SetMinSize(perkFrame.background, dialogX-25, (dialogY/2)+15)
    DCEI.SetSize(perkFrame.background, dialogX-15, (dialogY/2)-35)
    DCEI.SetBottomAlignmentInParent(perkFrame.background)
    DCEI.SetVerticalOffsetInParent(perkFrame.background, 5)
    DCEI.SetVerticalOffsetInParent(perkFrame.container, 10)
    DCEI.SetSpacing(perkFrame.container,10)
    DCEI.SetPaddingTop(perkFrame.container,10)
    DCEI.SetPaddingBottom(perkFrame.container,30)
    local noPerksText = DCEI.NewText(perkFrame.background)
    DCEI.SetText(noPerksText, "<color=yellow>".."You have no perks!\nEarn perks by raising your Team Experience to 100%!")
    --DCEI.SetTopAlignmentInParent(titleText)
    --DCEI.SetVerticalOffsetInParent(titleText, -25)
    DCEI.SetTextFontSize(noPerksText,25)
    DCEI.SetSize(noPerksText,dialogX-50,(dialogY/2)+15)
    
    --DCEI.SetPadding(perkFrame.container, 15)
    
    local teamScoreText = DCEI.NewText(perkFrame.background)
    DCEI.SetText(teamScoreText, "Team Score: "..(GetTeamScore()))
    DCEI.SetTopAlignmentInParent(teamScoreText)
    DCEI.SetVerticalOffsetInParent(teamScoreText, 25)
    DCEI.SetTextFontSize(teamScoreText,20)

    --Populate Heroes Info
    for index=1,8 do
        local button = DCEI.NewButton(stack)
        DCEI.SetMinSize(button, heroIconX, heroIconY)
        DCEI.SetMaxSize(button, heroIconX, heroIconY)
        local heroTypeName = DCEI.NewText(button)
        DCEI.SetTopAlignmentInParent(heroTypeName)
        DCEI.SetVerticalOffsetInParent(heroTypeName, 40)
        DCEI.SetMaxSize(heroTypeName, heroIconX+(spacing/2)+10, 30)
        DCEI.SetTextFontSize(heroTypeName,12)

        local vitalsLabel = DCEI.NewText(button)
        DCEI.SetBottomAlignmentInParent(vitalsLabel)
        DCEI.SetVerticalOffsetInParent(vitalsLabel, -40)
        DCEI.SetMaxSize(vitalsLabel, heroIconX+(spacing/2)+10, 30)
        DCEI.SetTextFontSize(vitalsLabel,15)
        if(index > PARTY_SIZE) then
            DCEI.SetBackgroundImage(button, "btn_blue2")
            DCEI.EnableButton(button,false)
            DCEI.SetText(heroTypeName, "")
            DCEI.SetText(vitalsLabel, "<color=green>".."")
        else
            DCEI.SetBackgroundImage(button, GetHeroIcon(index)) --Should be set to icon of the hero.
            DCEI.SetText(heroTypeName, partyUnits[index]) 
            local hpValueToDisplay = 100
            if(partyUnitHealth[index] == nil) then
                hpValueToDisplay = DCEI.UnitTypeHealth(partyUnits[index])
            else
                hpValueToDisplay = partyUnitHealth[index]
            end
            local colorTag = "<color=green>"
            if(hpValueToDisplay < DCEI.UnitTypeHealth(partyUnits[index])) then
                colorTag = "<color=yellow>"
            end
            if(partyUnitHealth[index] ~= nil and partyUnitHealth[index] <= 0) then
                DCEI.SetText(vitalsLabel, "<color=red>Dead")
            else
                DCEI.SetText(vitalsLabel, colorTag..(math.floor(hpValueToDisplay)).."/<color=green>"..math.floor(DCEI.UnitTypeHealth(partyUnits[index])))
            end
            
        end
    end
    local backgroundPanels = {"btn_purple", "btn_purple_light", "btn_blue2"}
    if(GetTableSize(playerPerks) >= 1) then
        DCEI.SetActive(noPerksText, false)
        for index=1, GetTableSize(playerPerks) do
            local button = DCEI.NewFrame(perkFrame.container)
            DCEI.SetBackgroundImage(button, backgroundPanels[(index % GetTableSize(backgroundPanels))+1])
            perkFrame[index] = button
            DCEI.SetMinSize(button, heroIconX, 45)
            DCEI.SetMaxSize(button, dialogX-45, heroIconY)
            local perkDesc = DCEI.NewText(button)
            DCEI.SetRightAlignmentInParent(perkDesc)
            --DCEI.SetVerticalOffsetInParent(perkDesc, 40)
            DCEI.SetMaxSize(perkDesc, dialogX-45, 30)
            DCEI.SetTextFontSizeMin(perkDesc,13)
            DCEI.SetTextFontSizeMax(perkDesc,18)
            DCEI.SetMatchParent(perkDesc,true,true)
            DCEI.SetTextFontSize(perkDesc,15)
            DCEI.SetText(perkDesc, playerPerks[index].description)
            
        end
    
    else
        DCEI.SetActive(noPerksText, true)
    end
    if(showOnCreate ~= nil) then
        teamViewDialog.SetActive(showOnCreate)
    else
        teamViewDialog.SetActive(false)
    end
    
    

end

local lootDialog = nil
local lootDialogShown = false
function CreateLootDialog(loot, callback)
    if(lootDialog ~= nil) then return end
    lootDialogShown = true
    
    local container = DCEI.NewFrame(root)
    lootDialog = container
    --DCEI.SetBottomAlignmentInParent(container)
    --DCEI.SetLeftAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 15)
    --DCEI.SetVerticalOffsetInParent(container, -5)
    local DIALOG_X = 350
    local padding = DCEI.NewFrame(container)
    local abilityFrame = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(abilityFrame, "frame_slot00")
    DCEI.SetBackgroundImageColor(abilityFrame, 246, 225, 87, 255 / 255)
    DCEI.SetMinSize(abilityFrame, DIALOG_X, 350)
    local titleText = DCEI.NewText(abilityFrame)
    DCEI.SetText(titleText, "Loot")
    DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -15)
    DCEI.SetTextFontSize(titleText, 25)

    -- Claim All Button
    local BUTTON_X = DIALOG_X - 25
    local BUTTON_Y = 40
    local button = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(button, "btn_grey")
    DCEI.SetBottomAlignmentInParent(button)
    DCEI.SetVerticalOffsetInParent(button, 18)
    DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
    DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)
    local buttonText = DCEI.NewText(button)
    DCEI.SetText(buttonText, "Take All")
    --DCEI.SetHorizontalOffsetInParent(levelButtonText, 150)
    DCEI.SetOnClickCallback(button, 
    function()
        local willPickPerk = false
        local perkLootItem = nil
        for lootID = 1, 4 do
            local lootItem = loot[lootID]
            if(lootItem ~= nil and lootItem.count > 0) then
                ClaimItem(lootItem)
                if(lootItem.name == "Perk") then
                    willPickPerk = true
                    perkLootItem = lootItem
                end
            end
        end
        DCEI.Destroy(lootDialog)
        PlaySound("[Sound] Gold Collect")
        lootDialogShown = false
        lootDialog = nil
        if(willPickPerk) then
            if(perkLootItem.count == 1) then
                CreatePerkDialog( GetRandomPerksToShow(), callback )
            elseif(perkLootItem.count == 2) then
                CreatePerkDialog( GetRandomPerksToShow() ,function()
                    CreatePerkDialog( GetRandomPerksToShow(), callback )
                end)
            else
                CreatePerkDialog( GetRandomPerksToShow() ,function()
                    CreatePerkDialog( GetRandomPerksToShow(), function()
                        CreatePerkDialog( GetRandomPerksToShow(), callback )
                    end )
                end)
            end
            
        else
            callback()
        end
        
    end)
    lootDialogShown = true
    BUTTON_X = DIALOG_X - 20
    BUTTON_Y = 50
    local OFFSET = 10
    local INITIAL_OFFSET = 50
    
    for lootID = 1, 4 do
        local lootItem = loot[lootID]
        if(lootItem ~= nil and lootItem.count > 0) then
            local imagePath = "btn_level"
            local iconPath = "icon_plus"
            local lootTextValue = lootItem.name.." x"..lootItem.count
            local textSize = 18
            if(lootItem.name == "Gold") then
                imagePath = "btn_level_coop_reward"
                iconPath = "icon_coin00"
                lootTextValue = "Gold x"..lootItem.count
                textSize = 30
            end
            if(lootItem.name == "Perk") then
                imagePath = "btn_level_coop"
                iconPath = "icon_towerslot_affinity_purple"
                lootTextValue = "Choose a Perk! (x"..lootItem.count..")"
               
            end
            if(lootItem.name == "Hero") then
                imagePath = "btn_level_coop"
                iconPath = "icon_towerslot_affinity_purple"
                lootTextValue = "Recruit Hero!"
            end
    
            local button = DCEI.NewFrame(container)
            local xPos = INITIAL_OFFSET + ((OFFSET + BUTTON_Y) * (lootID-1))
            
            DCEI.SetBackgroundImage(button, imagePath)
            DCEI.SetTopAlignmentInParent(button)
            DCEI.SetVerticalOffsetInParent(button, -1*xPos)
            DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
            DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)
    
            local image = DCEI.NewFrame(button)
            DCEI.SetBackgroundImage(image, iconPath)
            DCEI.SetLeftAlignmentInParent(image)
            DCEI.SetHorizontalOffsetInParent(image, 8)
            DCEI.SetVerticalOffsetInParent(image, 2)
            DCEI.SetMinSize(image, 35, 35)
            DCEI.SetMaxSize(image, 35, 35)
    
            local lootText = DCEI.NewText(button)
            DCEI.SetText(lootText, lootTextValue)
            DCEI.SetHorizontalOffsetInParent(lootText, 45)
            --DCEI.SetVerticalOffsetInParent(lootText, -15)
            DCEI.SetTextFontSize(lootText, textSize)
        end
        
        
        
        
    end

end

function CreateEndRunButton()
    
    local container = DCEI.NewFrame(root)
    local openButton = DCEI.NewButton(inventoryDialog)

    DCEI.SetBackgroundImage(openButton, "btn_green_pressed")
    DCEI.SetMinSize(openButton, 110, 60)
    DCEI.SetMaxSize(openButton, 110, 60)
    --DCEI.SetTopAlignmentInParent(openButton)
    DCEI.SetRightAlignmentInParent(openButton)
    DCEI.SetHorizontalOffsetInParent(openButton, 120)
    DCEI.SetVerticalOffsetInParent(openButton, 35)

    DCEI.SetOnClickCallback(openButton, function()
        if(battleOngoing == true) then
            ShowErrorText("A battle is ongoing!")
        else
            CompleteRun()
        end
    end)

    local openButtonText = DCEI.NewText(openButton)
    DCEI.SetText(openButtonText, "".."Complete Run")
    DCEI.SetTextFontSize(openButtonText,15)
    DCEI.SetMaxSize(openButtonText,105,55)

end

function ShowErrorText(text)
    ShowRelevantText("<color=red>"..text)
end

local relevantTextBox = nil
local relevantID = 0
function ShowRelevantText(text)
    if(relevantTextBox ~= nil) then 
        --DCEI.Destroy(relevantTextBox)
        --relevantTextBox = nil
    end
    relevantID = relevantID + 1
    local container = DCEI.NewFrame(root)
    --relevantTextBox = container
    --DCEI.SetBottomAlignmentInParent(container)
    --DCEI.SetLeftAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 15)
    --DCEI.SetVerticalOffsetInParent(container, -5)
    local DIALOG_X = 300
    local DIALOG_Y = 150
    local xPos = DCEI.GetMousePosition2D().x
    local yPos = DCEI.GetMousePosition2D().y
    local tempUnit = DCEI.CreateUnit(1,1,"Temp Marker Unit",xPos,yPos)
    --DCEI.LogMessage("Setting Roffset to :"..xPos..","..yPos)
    DCEI.SetHorizontalOffsetInParent(container, xPos)
    DCEI.SetVerticalOffsetInParent(container, yPos)
    local padding = DCEI.NewFrame(container)
    local options = {
        offset = {up = 0, front = 0, right = 0},
        center_at_unit_origin = false
    }
    DCEI.AttachToUnit(container,tempUnit,options)
    

    local abilityFrame = DCEI.NewFrame(padding)
    --DCEI.SetBackgroundImage(abilityFrame, "frame_slot00")
    --DCEI.SetBackgroundImageColor(abilityFrame, 246, 225, 87, 255 / 255)
    DCEI.SetMinSize(abilityFrame, DIALOG_X, DIALOG_Y)
    local possibleXTargets = {35,-35, 0}
    local targetXOffset = possibleXTargets[1+(relevantID % 3)]
    local targetYOffset = 25
    local animationDuration = 3
    local animationType = "InOutCubic"
    local titleText = DCEI.NewText(abilityFrame)
    DCEI.SetText(titleText, text)
    --DCEI.SetTopAlignmentInParent(titleText)
    DCEI.SetVerticalOffsetInParent(titleText, -15)
    DCEI.SetTextFontSize(titleText, 22)
    DCEI.AnimateAlpha(abilityFrame,1,0,animationDuration,animationType)
    DCEI.AnimateHorizontalOffset(titleText,0,targetXOffset,animationDuration,"OutSine")
    DCEI.AnimateVerticalOffset(titleText,-15,targetYOffset,animationDuration,"OutSine")
end

local clearTooltipsHelper = nil
function ClearTooltips()
    
    --[[local container = DCEI.NewFrame(root)
    clearTooltipsHelper = container
    --relevantTextBox = container
    --DCEI.SetBottomAlignmentInParent(container)
    --DCEI.SetLeftAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 15)
    --DCEI.SetVerticalOffsetInParent(container, -5)
    DCEI.SetMatchParent(container,true,true)
    DCEI.SetBackgroundImageColor(container,1,1,1,0)
    DCEI.SetBlockInput(container, false)
    local DIALOG_X = 300
    local DIALOG_Y = 150
    local xPos = DCEI.GetMousePosition2D().x
    local yPos = DCEI.GetMousePosition2D().y
    local tempUnit = DCEI.CreateUnit(1,1,"Temp Marker Unit",xPos,yPos)
    --DCEI.LogMessage("Setting Roffset to :"..xPos..","..yPos)
    DCEI.SetHorizontalOffsetInParent(container, xPos)
    DCEI.SetVerticalOffsetInParent(container, yPos)
    
    local padding = DCEI.NewFrame(container)
    local options = {
        offset = {up = 0, front = 0, right = 0},
        center_at_unit_origin = false
    }
    DCEI.AttachToUnit(container,tempUnit,options)]]
    
    --DCEI.SetTooltipText(container," ")
    --[[ExecuteAfter(function()
        DCEI.SetHorizontalOffsetInParent(clearTooltipsHelper, 1000)
        DCEI.SetVerticalOffsetInParent(clearTooltipsHelper, 1000)
        DCEI.SetUnitPosition2D(tempUnit, 42, 6)
    end,0.1)
    --
    ExecuteAfter(function()
        DCEI.SetTooltipText(clearTooltipsHelper,"")
        --DCEI.Wait(0.01)
        ExecuteAfter(function()
            DCEI.LogMessage("Destroying CTH!")
            DCEI.Destroy(clearTooltipsHelper)
        end,0.05)
    end,0.05)]]
    
    
end

local fadeDialog = nil
function FadeScreen(state, time)
    if(state == true) then
        local container = DCEI.NewFrame(root)
        fadeDialog = container
        DCEI.SetBackgroundImage(container,"blackScreen")
        DCEI.SetMatchParent(container,true,true)
        DCEI.AnimateAlpha(container,0,1,time,"OutSine")

    else
        DCEI.AnimateAlpha(fadeDialog,1,0,time,"OutSine")
    end
    
    
end

local targetingDialog = nil
function ShowTargetingDialog(abilityName)
    local container = DCEI.NewFrame(root)
    targetingDialog = container
    --local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(container, "frame05")
    DCEI.SetBackgroundImageColor(container, 1,.2,.2,1)
    DCEI.SetSize(container, 650, 75)
    DCEI.SetTopAlignmentInParent(container)
    DCEI.SetVerticalOffsetInParent(container,-50)
    DCEI.AnimateAlpha(container, 0, 1, 0.5, "OutSine")

    local text = DCEI.NewText(container)
    DCEI.SetText(text,"Choose a Target! ("..abilityName..")")
    DCEI.SetSize(text,450,67)
end

local overheadDialog = nil
function ShowOverheadMessage(messageText, showTime, color)
    local container = DCEI.NewFrame(root)
    local thickBG = DCEI.NewFrame(container)
    targetingDialog = container
    DCEI.SetBackgroundImage(container, "frame05")
    DCEI.SetBackgroundImage(thickBG, "frame05")
    DCEI.SetMatchParent(thickBG,true,true)
    if(color ~= nil) then
        DCEI.SetBackgroundImageColor(container, color[1],color[2],color[3],color[4])
        DCEI.SetBackgroundImageColor(thickBG, color[1],color[2],color[3],color[4])
    else
        DCEI.SetBackgroundImageColor(container, 1,1,1,1)
        DCEI.SetBackgroundImageColor(thickBG, 0,0,0,1)
    end
    
    DCEI.SetSize(container, 650, 75)
    DCEI.SetTopAlignmentInParent(container)
    DCEI.SetVerticalOffsetInParent(container,-50)
    DCEI.AnimateAlpha(container, 0, 1, 0.5, "OutSine")

    local text = DCEI.NewText(container)
    DCEI.SetText(text,messageText)
    DCEI.SetSize(text,450,67)

    ExecuteAfter(function()
        DCEI.AnimateAlpha(container, 1, 0, 0.3, "OutSine")
    end,showTime)
end


function HideTargetingDialog()
    DCEI.AnimateAlpha(targetingDialog, 1, 0, 0.25, "OutSine")
    DCEI.Wait(0.25)
    DCEI.Destroy(targetingDialog)
end

local isChoosingPerk = false
function CreatePerkDialog(perks,callback)
    isChoosingPerk = true
    local container = DCEI.NewFrame(root)
    --DCEI.SetTopAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)

    local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(padding, "frame_slot00")
    DCEI.SetMinSize(padding, 500, 420)
    DCEI.SetMaxSize(padding, 500, 420)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 255 / 255)

    
    --Header Image

    local header = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(header, "frame_half_top_purple")
    DCEI.SetMinSize(header, 480, 70)
    DCEI.SetMaxSize(header, 480, 70)
    DCEI.SetTopAlignmentInParent(header)
    DCEI.SetVerticalOffsetInParent(header,-10)

    local text = DCEI.NewText(header)
    DCEI.SetText(text, "Choose a Perk!")
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -15)
    DCEI.SetTextFontSize(text, 35)

    --[[local closeButton = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(closeButton, "btn_red")
    DCEI.SetBottomAlignmentInParent(closeButton)
    DCEI.SetHorizontalOffsetInParent(closeButton, 0)
    DCEI.SetVerticalOffsetInParent(closeButton, 20)
    DCEI.SetMinSize(closeButton, 470, 40)
    DCEI.SetMaxSize(closeButton, 470, 40)

    local text = DCEI.NewText(closeButton)
    DCEI.SetText(text, "Close Shop")
    --DCEI.SetTopAlignmentInParent(text)
    --DCEI.SetVerticalOffsetInParent(text, -15)
    DCEI.SetTextFontSize(text, 20)
    DCEI.SetOnClickCallback(closeButton, 
    function()
        DCEI.Destroy(container)
        OnShoppingEnded()
        
    end)]]

    --local INITIAL_OFFSET = -90
    local SHOP_X = 80
    local SHOP_Y = 80
    local SHOP_OFFSET = 30
    for perkID = 1, 3 do
            local perk = perks[perkID]
            local imagePath = perk.image
            --local description = HighlightKeywords(heroOption.description)
            --DCEI.LogMessage("Got Image path:"..imagePath)
            
            local button = DCEI.NewButton(container)
            local yPos = -75 + ((SHOP_OFFSET + SHOP_Y) * (perkID-1))
            DCEI.SetBackgroundImage(button, imagePath)
            DCEI.SetLeftAlignmentInParent(button)
            DCEI.SetHorizontalOffsetInParent(button, 20)
            DCEI.SetVerticalOffsetInParent(button, -1*yPos)
            DCEI.SetMinSize(button, SHOP_X, SHOP_Y)
            DCEI.SetMaxSize(button, SHOP_X, SHOP_Y)
            
            --[[local icon = DCEI.NewButton(container)
            DCEI.SetBackgroundImage(button, imagePath)
            DCEI.SetLeftAlignmentInParent(button)
            DCEI.SetHorizontalOffsetInParent(button, 25)
            DCEI.SetVerticalOffsetInParent(button, -1*yPos)
            DCEI.SetMinSize(button, SHOP_X, SHOP_Y)
            DCEI.SetMaxSize(button, SHOP_X, SHOP_Y)]]

            DCEI.SetOnClickCallback(button, 
            function()
                
                OnPerkSelected(perk)
                DCEI.Destroy(container)
                isChoosingPerk = false
                callback()
            end)
    
            local titleText = DCEI.NewText(container)
            DCEI.SetText(titleText, "<color=yellow>"..perk.name.."</color>\n"..perk.description)
            --DCEI.SetRightAlignmentInParent(titleText)
            --DCEI.SetHorizontalOffsetInParent(titleText, 170)
            --DCEI.SetVerticalOffsetInParent(titleText, 0)
            DCEI.SetLeftAlignmentInParent(titleText)
            DCEI.SetHorizontalOffsetInParent(titleText, 40 + SHOP_X)
            DCEI.SetVerticalOffsetInParent(titleText, -1*yPos)
            DCEI.SetTextFontSize(titleText, 17)
            DCEI.SetMaxSize(titleText, SHOP_X*4.5, SHOP_Y)

    end



    
    return {
        frame = container,
    }
end

function OnPerkSelected(selectedPerk)
    levelsWithoutPerk = 0
    table.insert(playerPerks, selectedPerk)
    if(selectedPerk.name == "Barterer") then
        foreach(shopItems, function(item)
            item.cost = math.floor(item.cost - (item.cost/10))
        end)
    end
    if(selectedPerk.name == "Campfire") then
        campfireActive = true
    end
    if(selectedPerk.name == "Resurrect") then
        local deadHeroesIndexs = {}
        for index=1,PARTY_SIZE do
            if(partyUnitHealth[index] ~= nil and partyUnitHealth[index] <= 0) then
                table.insert(deadHeroesIndexs, index)
            end
        end
        if(GetTableSize(deadHeroesIndexs) >= 1) then
            local heroToRevive = deadHeroesIndexs[1]
            partyUnitHealth[heroToRevive] = DCEI.UnitTypeHealth(partyUnits[heroToRevive])
        end
        
    end
    if(selectedPerk.name == "Scavenging") then
        playerGold = playerGold + 30
        ClaimItem(GetRandomElement(shopItems))
        UpdateGoldPanel()
    end

    if(selectedPerk.name == "Last Stand") then
        lastStandActive = true
        
    end
    DCEI.LogMessage("Perk selected: "..selectedPerk.name..". New perk count: "..GetPerkCount(selectedPerk))
end

function PerkRequirementMet(perk)
    if(perk.specialRequirement == nil) then return true end
    return false
end

function GetRandomPerksToShow()
    local returnPerks = {}
    local allPossiblePerks = {}
    foreach(gamePerks,function(perk)
        if(forcedPerkOffering ~= nil) then
            for index=1,20 do
                table.insert(allPossiblePerks, forcedPerkOffering)
            end
        end
        if((GetPerkCount(perk) <= 0 or perk.stackable == true) and (perk.requiredDungeonLevel == nil or roomsCleared >= perk.requiredDungeonLevel) and (PerkRequirementMet(perk) == true)) then
            table.insert(allPossiblePerks, perk)
        end

    end)

    returnPerks = ShuffleTable(allPossiblePerks)
    forcedPerkOffering = nil
    return returnPerks
end

function GiveFreePerk(perksToGive, endPhase)
    if(endPhase == nil) then
        endPhase = true
    end
    ToggleMapFrame(false)
    if(perksToGive == nil or perksToGive == 1) then
        CreatePerkDialog(GetRandomPerksToShow(), function()
            if(endPhase == true) then
                OnShoppingEnded()
            end
            
        end)
    elseif(perksToGive == 2) then
        CreatePerkDialog( GetRandomPerksToShow() ,function()
            CreatePerkDialog( GetRandomPerksToShow(), function()
                if(endPhase == true) then
                    OnShoppingEnded()
                end
            end )
        end)
    elseif(perksToGive == 3) then
        CreatePerkDialog( GetRandomPerksToShow() ,function()
            CreatePerkDialog( GetRandomPerksToShow(), function()
                CreatePerkDialog( GetRandomPerksToShow(), function()
                    if(endPhase == true) then
                        OnShoppingEnded()
                    end
                end )
            end )
        end)
    elseif(perksToGive == 4) then
        CreatePerkDialog( GetRandomPerksToShow() ,function()
            CreatePerkDialog( GetRandomPerksToShow(), function()
                CreatePerkDialog( GetRandomPerksToShow(), function()
                    CreatePerkDialog( GetRandomPerksToShow(), function()
                        if(endPhase == true) then
                            OnShoppingEnded()
                        end
                    end )
                end )
            end )
        end)
    end
    
end


--Called when heroes are spawned in but before battle begins. Handles any perks/affinities that should be executed before combat start.
function ApplyPreBattlePerks()
    --DCEI.LogMessage("Applying pre-battle perks!")
    foreach(playerPerks,function(perk)
        if(perk.name == "Grit") then
            --DCEI.LogMessage("Applying pre-battle perk: GRIT!")
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and (DCEI.UnitName(partyUnit) == "Berserker" or DCEI.UnitName(partyUnit) == "Rifleman")) then
                    --DCEI.LogMessage("(Grit) Applying Armored behavior to unit:"..DCEI.UnitName(partyUnit))
                    DCEI.ApplyBehaviorWithDuration(partyUnit,"Armored",90)
                    --table.insert(affinityTokens, "Armored")
                end
            end)
            
        end

    end)
    --DCEI.LogMessage("Finished applying pre-battle perks!")
end

-- Called at the start of every battle, applies any behavior/battle specific perks.
function ApplyBattlePerks()
    --affinityTokens = {}
    foreach(AFFINITIES, function(affinity)
        if(affinity.bonusActive == true) then
            if(affinity.name == "Specialist") then
                --DCEI.LogMessage("Applying specialist bonus perk!")
                foreach(party,function(partyUnit)
                    if(UnitIsAlive(partyUnit) and DCEI.UnitBehaviorStackCount(partyUnit, affinity.name) >= 1) then
                        local nearby = GetAdjacentHeroUnits(partyUnit)
                        foreach(nearby, function(unit)
                            DCEI.ApplyBehaviorCount(unit, "Mobile", 1)
                        end)
                        --ShowSpeechBubble(partyUnit, 15, "This is our last stand!",5)
                    end
                end)
            end

            if(affinity.name == "Naturalist") then
                --DCEI.LogMessage("Applying naturalist bonus perk!")
                local spawnPoint = GetClosestHexPointToPoint(GetRandomHeroPosition(),true)
                DCEI.CreateUnitWithFacing(1, 1, "Armored Golem", spawnPoint.x, spawnPoint.y, enemySpawnPoints[1].x, enemySpawnPoints[1].y)
            end
        end
        local count = GetAffinityCount(affinity)
        if(affinity.name == "Bonus" and count > 0) then
            
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit)) then
                    
                    DCEI.ApplyBehaviorCount(partyUnit, "AffinityBonusDamage", count)
                    --DCEI.LogMessage("Applying "..count.." xAffinity Bonus damage to hero: "..DCEI.UnitName(partyUnit))
                end
            end)
        end
    end)

    if(lastStandActive) then
        foreach(party,function(partyUnit)
            if(UnitIsAlive(partyUnit)) then
                DCEI.ApplyBehavior(partyUnit,"Last Stand")
                --ShowSpeechBubble(partyUnit, 15, "This is our last stand!",5)
            end
        end)
    end

    if(campfireActive) then
        campfireActive = false
        foreach(party,function(partyUnit)
            if(UnitIsAlive(partyUnit)) then
                HealUnit(partyUnit,40, "Campfire (+40)")
            end
        end)
    end
    foreach(playerPerks,function(perk)
        if(perk.name == "Giantslayer") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and eliteFight == true) then
                    DCEI.ApplyBehavior(partyUnit,"Giantslayer")
                    --DCEI.LogMessage("Applying Giantslayer to unit:"..DCEI.UnitName(partyUnit))
                end
            end)
            
        end
        if(perk.name == "Persistence") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit)) then
                    DCEI.ApplyBehavior(partyUnit,"Persistence")
                    --DCEI.LogMessage("Applying Persistence to unit:"..DCEI.UnitName(partyUnit))
                end
            end)
            
        end
        if(perk.name == "Quickness") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit)) then
                    DCEI.ApplyBehavior(partyUnit,"Fleetfoot")
                    --DCEI.LogMessage("Applying Fleetfoot to unit:"..DCEI.UnitName(partyUnit))
                end
            end)
            
        end
        if(perk.name == "Absolute Focus") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit)) then
                    DCEI.ApplyBehavior(partyUnit,"Absolute Focus")
                    --DCEI.LogMessage("Applying Absolute Focus to unit:"..DCEI.UnitName(partyUnit))
                end
            end)
            
        end
        if(perk.name == "Inspired Call") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and DCEI.UnitName(partyUnit) == "Legionnaire") then
                    DCEI.CreateEffect("Legion's Call",partyUnit,DCEI.GetUnitPosition2D(partyUnit).x,DCEI.GetUnitPosition2D(partyUnit).y)
                end
            end)
            
        end
        --[[if(perk.name == "Grit") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and (DCEI.UnitName(partyUnit) == "Berserker" or DCEI.UnitName(partyUnit) == "Rifleman")) then
                    DCEI.LogMessage("(Grit) Applying Armored behavior to unit:"..DCEI.UnitName(partyUnit))
                    DCEI.ApplyBehaviorWithDuration(partyUnit,"Armored",90)
                    table.insert(affinityTokens, "Armored")
                    
                end
            end)
            
        end]]
        if(perk.name == "Team Discipline") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and DoesPartyHaveDuplicatesOf(DCEI.UnitType(partyUnits) == false)) then
                    DCEI.ApplyBehaviorWithDuration(partyUnit,"Team Discipline",90)
                end
            end)
            
        end
        if(perk.name == "Stealth Archers") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and DCEI.UnitName(partyUnit) == "Archer") then
                    DCEI.ApplyBehaviorWithDuration(partyUnit,"Stealth",4,false)
                end
            end)
            
        end
        if(perk.name == "Fiery Focus") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and DCEI.UnitName(partyUnit) == "Pyromancer") then
                    DCEI.ApplyBehavior(partyUnit,"Fiery Focus")
                end
            end)
            
        end
        if(perk.name == "Improved Armor") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit)) then
                    DCEI.ApplyBehavior(partyUnit,"Improved Armor")
                end
            end)
            
        end
        if(perk.name == "Improved Weapons") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit)) then
                    DCEI.ApplyBehavior(partyUnit,"Improved Weapons")
                end
            end)
            
        end
        if(perk.name == "Steadfast") then
            foreach(party,function(partyUnit)
                if(UnitIsAlive(partyUnit) and UnitIsMelee(partyUnit)) then
                    DCEI.ApplyBehavior(partyUnit,"Steadfast")
                    DCEI.AddHealth(partyUnit, 60)
                end
            end)
            
        end
    end)
end

function GetPerkCount(perk)
    local returnCount = 0
    for index=1,GetTableSize(playerPerks) do
        if(playerPerks[index].name == perk.name) then
            returnCount = returnCount + 1
        end
    end
    return returnCount
end

function GetPerkCountByName(perkName)
    local returnCount = 0
    for index=1,GetTableSize(playerPerks) do
        if(playerPerks[index].name == perkName) then
            returnCount = returnCount + 1
        end
    end
    return returnCount
end

function UpdateActiveAffinities()
    DCEI.Destroy(affinityDialogFrame)
    
    foreach(AFFINITIES, function(affinity)
        --local tooltipText = affinity.passiveDescription.."\n______________\n("..affinity.requiredCount..") - "..affinity.description
        --tooltipText = HighlightKeywords(tooltipText)
        --DCEI.LogMessage("Got TT text for affinity:"..tooltipText)
        local affinCount = GetAffinityCount(affinity)
        --DCEI.LogMessage("Got affinity count:"..affinCount.." for affinity: "..affinity.name)
        if(affinCount >= 1 or (affinity.name == "Bonus" and roomsCleared >= 1)) then
            affinity.isActive = true
            if((affinCount == affinity.requiredCount or (affinCount >= affinity.requiredCount and affinity.requireExactCount == false)) and affinity.name ~= "Bonus" and affinity.name ~= "Nightmare") then
                affinity.bonusActive = true
            else
                affinity.bonusActive = false
            end
            --[[DCEI.SetBackgroundImageGrayScale(affinity.button,false)
            DCEI.SetBackgroundImageColor(affinity.button,1,1,1,225/255)
            DCEI.SetTooltipText(affinity.button,tooltipText)
            DCEI.SetText(affinity.countText,affinCount)]]
            
        else
            
            --[[DCEI.SetBackgroundImageGrayScale(affinity.button,true)
            DCEI.SetBackgroundImageColor(affinity.button,1,1,1,140/255)
            DCEI.SetTooltipText(affinity.button,tooltipText)
            DCEI.SetText(affinity.countText,"")]]
            affinity.isActive = false
            affinity.bonusActive = false
        end
    end)
    CreateAffinityFrame()
    ApplyAffinityBonuses()
end

function ApplyAffinityBonuses()
    foreach(AFFINITIES, function(affinity) 
        if(affinity.bonusActive) then
            foreach(party, function(hero)
                if(UnitIsAlive(hero) and DCEI.UnitBehaviorStackCount(hero, affinity.name) > 0 and affinity.name ~= "Bonus" and affinity.name ~= "Nightmare") then
                    if(affinity.hasDedicatedBehavior == true) then
                        DCEI.ApplyBehaviorCount(hero, "AffinityBonus_"..affinity.name)
                    end
                    
                    --DCEI.LogMessage("Applying affinity bonus to unit: "..DCEI.UnitName(hero))
                end
            end)
        end
        
    end)
end

function GetAffinityCount(affinity)
    local returnCount = 0
    if(affinity.name == "Bonus") then
        foreach(AFFINITIES, function(affinity) 
            if(affinity.bonusActive and affinity.name ~= "Bonus") then
                returnCount = returnCount + 1
            end
        end)
        return returnCount
    end
    foreach(affinityTokens, function(tokenName)
        if(tokenName == affinity.name) then
            returnCount = returnCount + 1
        end
        
    end)
    --[[foreach(HERO_TYPES, function(hType)
        local countOfType = GetHeroTypeCount(hType)
        DCEI.LogMessage("Got "..countOfType.." count of hero type: "..hType.name)
        foreach(hType.affinities, function(affin)
            if(affin.name == affinity.name) then
                returnCount = returnCount + countOfType
            end
            
        end)
    
    end)]]
    foreach(partyUnits, function(heroType)
        if(heroType ~= nil and heroType ~= "") then
            local hType = GetHeroTypeFromUnitName(heroType)
            foreach(hType.affinities, function(affin)
                if(affin.name == affinity.name) then
                    returnCount = returnCount + 1
                end
                
            end)
        end
    end)
    return returnCount
end

--Counts only affinity bonus tokens with the given affinity name.
function GetAffinityTokenCount(affinityName)
    local returnCount = 0
    foreach(affinityTokens, function(tokenName)
        if(tokenName == affinityName) then
            returnCount = returnCount + 1
        end
        
    end)
    return returnCount
end

function GetHeroTypeFromUnitName(unitName)
    local returnHType = nil
    foreach(HERO_TYPES, function(hType)
        if(hType.name == unitName) then
            returnHType = hType
        end
    
    end)
    return returnHType
end

function GetHeroTypeCount(heroType)
    local returnCount = 0
    for index=1,PARTY_SIZE do
        if(partyUnits[index] == heroType.name and UnitIsAlive(party[index])) then
            returnCount = returnCount + 1
        end
        
    end
    return returnCount
end



local MAX_STOCK = 3
local itemShopText = {}
function CreateShopDialog(callback)
    local container = DCEI.NewFrame(root)
    --DCEI.SetTopAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)
    
    local padding = DCEI.NewFrame(container)
    local dialogX = 620
    local dialogY = 355
    DCEI.SetBackgroundImage(padding, "frame_slot00")
    DCEI.SetMinSize(padding, dialogX, dialogY)
    DCEI.SetMaxSize(padding, dialogX, dialogY)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 200 / 255)

    
    --Header Image

    local header = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(header, "frame_half_top_yellow")
    DCEI.SetMinSize(header, dialogX-20, 70)
    DCEI.SetMaxSize(header, dialogX-20, 70)
    DCEI.SetTopAlignmentInParent(header)
    DCEI.SetVerticalOffsetInParent(header,-10)

    local text = DCEI.NewText(header)
    DCEI.SetText(text, "Buy Items!")
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -15)
    DCEI.SetTextFontSize(text, 35)

    local closeButton = DCEI.NewButton(container)
    DCEI.SetBackgroundImage(closeButton, "btn_red")
    DCEI.SetBottomAlignmentInParent(closeButton)
    DCEI.SetHorizontalOffsetInParent(closeButton, 0)
    DCEI.SetVerticalOffsetInParent(closeButton, 20)
    DCEI.SetMinSize(closeButton, 470, 40)
    DCEI.SetMaxSize(closeButton, 470, 40)

    local text = DCEI.NewText(closeButton)
    DCEI.SetText(text, "Close Shop")
    --DCEI.SetTopAlignmentInParent(text)
    --DCEI.SetVerticalOffsetInParent(text, -15)
    DCEI.SetTextFontSize(text, 20)
    DCEI.SetOnClickCallback(closeButton, 
    function()
        DCEI.Destroy(container)
        OnShoppingEnded()
        
    end)

    --local INITIAL_OFFSET = -90
    local SHOP_X = 80
    local SHOP_Y = 80
    local SHOP_OFFSET = 22
    local itemsPerColumn = 2
    local buttonTextOffset = SHOP_X + 15
    shopItemsToShow = GetRandomShopItems()
    for shopID = 1, 2 do
            local shopItem = shopItemsToShow[shopID]


            local imagePath = shopItem.image
            --local description = HighlightKeywords(heroOption.description)
            
            local button = DCEI.NewButton(container)
            local yPos = -142 + ((SHOP_OFFSET + SHOP_Y) * (((shopID-1) % itemsPerColumn)+1))
            local bonusX = (SHOP_X + 220) 
            if(shopID <= itemsPerColumn) then
                bonusX = 0
            end
            DCEI.SetBackgroundImage(button, imagePath)
            DCEI.SetLeftAlignmentInParent(button)
            DCEI.SetHorizontalOffsetInParent(button, 25+bonusX)
            DCEI.SetVerticalOffsetInParent(button, -1*yPos)
            DCEI.SetMinSize(button, SHOP_X, SHOP_Y)
            DCEI.SetMaxSize(button, SHOP_X, SHOP_Y)
            DCEI.SetTooltipText(button, shopItem.tooltip)
            
            --[[local icon = DCEI.NewButton(container)
            DCEI.SetBackgroundImage(button, imagePath)
            DCEI.SetLeftAlignmentInParent(button)
            DCEI.SetHorizontalOffsetInParent(button, 25)
            DCEI.SetVerticalOffsetInParent(button, -1*yPos)
            DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
            DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)]]

            DCEI.SetOnClickCallback(button, 
            function()
                AttemptBuyItem(shopItem)
            end)
    
            local titleText = DCEI.NewText(container)
            itemShopText[shopID] = titleText
            DCEI.SetText(titleText, GetItemShopItemText(shopID))
            DCEI.SetLeftAlignmentInParent(titleText)
            DCEI.SetHorizontalOffsetInParent(titleText, 25+bonusX+buttonTextOffset)
            DCEI.SetVerticalOffsetInParent(titleText, -1*yPos)

    end



    ToggleMapFrame(false)
    return {
        frame = container,
    }
end

function GetRandomShopItems()
    local possibleItems = {}
    --[[foreach(shopItems, function(item)
        --DCEI.LogMessage("Got item:"..item.name)
        --if(item.flags == nil) then  DCEI.LogMessage("Item is a nilflag-treasure item!") end
        --if(item.flags ~= nil and item.flags.treasureItem == true) then  DCEI.LogMessage("Item IS treasure item!") end
        --if(string.match(item.name, "Affinity Tome:") == true) then DCEI.LogMessage("Item FAILS non-affinity tome check.") end
        if((item.flags == nil or item.flags.treasureItem == nil or item.flags.treasureItem == false) and item ~= nil) then
            --DCEI.LogMessage("Got viable shop item:"..item.name)
            table.insert(possibleItems, item)
        end
    end)]]
    possibleItems = {shopItems[1],shopItems[2]}
    return possibleItems
end
--local testItems = GetRandomShopItems()
shopItemsToShow = GetRandomShopItems()
--DCEI.LogMessage("Got : "..#testItems.." viable shop items!")
function AttemptBuyItem(shopItem)
    --DCEI.LogMessage("Attempted to buy item: "..shopItem.name)
    if(playerGold >= shopItem.cost and GetRemainingStockForItem(shopItem) > 0) then
        playerGold = playerGold - shopItem.cost
        UpdateGoldPanel()
        ClaimItem(shopItem)
        table.insert(recentlyPurchasedItems,shopItem)
        PlaySound("[Sound] Gold Collect")
        UpdateShopItemListings()
    elseif(playerGold < shopItem.cost) then
        ShowErrorText("Not enough gold!")
    else
        ShowErrorText("Out of stock!")
    end
end

function UpdateShopItemListings()
    for shopID = 1, 4 do
        DCEI.SetText(itemShopText[shopID], GetItemShopItemText(shopID))
    end
end


function GetRemainingStockForItem(item)
    local returnCount = MAX_STOCK
    foreach(recentlyPurchasedItems, function(purchasedItem)
        if(purchasedItem.name == item.name) then
            returnCount = returnCount - 1
        end

    end)
    return returnCount
end

function GetItemShopItemText(shopID)
    local shopItem = shopItemsToShow[shopID]
    local colorString = "<color=yellow>"
    local stock = GetRemainingStockForItem(shopItem)
    if(stock <= 0) then
        colorString = "<color=#808080ff>"
    end
    return shopItem.name.."\n"..colorString.."Cost: "..shopItem.cost.."\n<size=18>("..stock.." left)"
end

function RecruitHeroToParty(heroOption)
    PARTY_SIZE = PARTY_SIZE + 1
    partyUnits[PARTY_SIZE] = heroOption.name
    DCEI.ShowFeedbackMessage(heroOption.name.." joined your party!")
end

--[[function RecruitUnitToParty(unitName)
    PARTY_SIZE = PARTY_SIZE + 1
    partyUnits[PARTY_SIZE] = unitName
    DCEI.ShowFeedbackMessage(unitName.." joined your party!")
end]]

local heroChoicesMade = 0
function PresentHeroChoice(heroOptions, callback)
    if(forcedHeroChoice ~= nil) then
        heroOptions[1] = forcedHeroChoice
    end
    ToggleMapFrame(false)
    heroChoicesMade = heroChoicesMade + 1
    local container = DCEI.NewFrame(root)
    --DCEI.SetTopAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)

    local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(padding, "frame_slot00")
    DCEI.SetMinSize(padding, 600, 420)
    DCEI.SetMaxSize(padding, 600, 420)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 200 / 255)

    local text = DCEI.NewText(padding)
    DCEI.SetText(text, "Recruit a Hero!")
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -15)
    DCEI.SetTextFontSize(text, 25)

    local INITIAL_OFFSET = -105
    local BUTTON_X = 80
    local BUTTON_Y = 80
    local OFFSET = 40
    for heroID = 1, 1 do
        local heroOption = heroOptions[heroID]
        if(heroOption == nil) then
            heroOption = {name = "Locked", image = "lock", description = "This hero is locked. You have not yet discovered them."}
        end
        if(heroOption ~= nil) then
            local imagePath = heroOption.image
            local description = HighlightKeywords(heroOption.description)
            
            
            local yPos = INITIAL_OFFSET + ((OFFSET + BUTTON_Y) * (heroID-1))
            
            local heroBG = DCEI.NewFrame(container)
            DCEI.SetSize(heroBG,570,100)
            DCEI.SetBackgroundImage(heroBG,"frame_dark_stroke")
            DCEI.SetBackgroundImageColor(heroBG,87/255, 147/255,242/255,1)
            --DCEI.SetLeftAlignmentInParent(heroBG)
            DCEI.SetHorizontalOffsetInParent(heroBG, 0)
            DCEI.SetVerticalOffsetInParent(heroBG, -1*yPos + 0)

           
            

            local iconStack = DCEI.NewFrame(heroBG)
            DCEI.SetSize(iconStack,220,68)
            DCEI.SetBackgroundImage(iconStack,"frame05")
            DCEI.SetLeftAlignmentInParent(iconStack)
            DCEI.SetHorizontalOffsetInParent(iconStack, 70)
            --DCEI.SetVerticalOffsetInParent(iconStack, 12)

            local button = DCEI.NewButton(heroBG)
            DCEI.SetBackgroundImage(button, imagePath)
            DCEI.SetLeftAlignmentInParent(button)
            DCEI.SetHorizontalOffsetInParent(button, 12)
            DCEI.SetVerticalOffsetInParent(button, -2)
            --DCEI.SetVerticalOffsetInParent(button, -1*yPos)
            DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
            DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)
            
            local onSelectCallback = function()
                RecruitHeroToParty(heroOption)
                DCEI.Destroy(container)
                callback()
            end
            DCEI.SetOnClickCallback(button, onSelectCallback )

            local affinStack = DCEI.NewHStack(heroBG)
            
            DCEI.SetSize(affinStack,255,45)
            DCEI.SetBackgroundImageColor(affinStack,1,1,1,0)
            DCEI.SetBackgroundImage(affinStack,"frame05")
            DCEI.SetRightAlignmentInParent(affinStack)
            DCEI.SetHorizontalOffsetInParent(affinStack, -10)
            DCEI.SetSpacing(affinStack,11)
            local buttonAlpha = 0
            if(roomsCleared >= 2) then
                buttonAlpha = 0.45
            end
            for index=1,2 do
                local affinIcon = DCEI.NewFrame(affinStack)
                if(heroOption.affinities[index] == nil) then
                    DCEI.SetSize(affinIcon,55,55)
                    DCEI.SetBackgroundImage(affinIcon, "affinityEmptyIcon")
                    DCEI.SetBackgroundImageColor(affinIcon,1,1,1,buttonAlpha)
                    
                else
                    DCEI.SetSize(affinIcon,55,55)
                    DCEI.SetBackgroundImage(affinIcon, heroOption.affinities[index].image)
                    local affinity = heroOption.affinities[index]
                    if(roomsCleared >= 2) then
                        buttonAlpha = 1
                    end
                    local tooltipText = HighlightKeywords(affinity.passiveDescription..GetAffinityBonusDescriptionText(affinity))
                    DCEI.SetBackgroundImageColor(affinIcon,1,1,1,buttonAlpha)
                    DCEI.SetTooltipText(affinIcon, tooltipText)
                end
                
                
            end
            --[[foreach(heroOption.affinities, function(affinity)
                DCEI.LogMessage("Creating affinity icon: "..affinity.name.." for hero :"..heroOption.name)
                local affinIcon = DCEI.NewFrame(affinStack)
                DCEI.SetSize(affinIcon,55,55)
                DCEI.SetBackgroundImage(affinIcon, affinity.image)
                --DCEI.SetLeftAlignmentInParent(affinIcon)
                --DCEI.SetHorizontalOffsetInParent(affinIcon, 70)
            end)]]
            local passiveIcon = DCEI.NewFrame(affinStack)
            DCEI.SetSize(passiveIcon,55,55)
            DCEI.SetBackgroundImage(passiveIcon, "hero_activeInfo")
            DCEI.SetTooltipText(passiveIcon,description)
            --[[passiveIcon = DCEI.NewFrame(affinStack)
            DCEI.SetSize(passiveIcon,55,55)
            DCEI.SetBackgroundImage(passiveIcon, "hero_activeInfo")]]

            button = DCEI.NewButton(affinStack)
            DCEI.SetBackgroundImage(button, "btn_green")
            --DCEI.SetLeftAlignmentInParent(button)
            --DCEI.SetHorizontalOffsetInParent(button, 12)
            --DCEI.SetVerticalOffsetInParent(button, -2)
            --DCEI.SetVerticalOffsetInParent(button, -1*yPos)
            DCEI.SetSize(button, 60, 60)
            DCEI.SetOnClickCallback(button, onSelectCallback )

            local checkmark = DCEI.NewFrame(button)
            DCEI.SetBackgroundImage(checkmark, "tick02")
            DCEI.SetBackgroundImageColor(checkmark, 1,1,1,.65)
            DCEI.SetSize(checkmark, 30, 30)
            
            --[[local descText = DCEI.NewText(container)
            DCEI.SetText(descText, description)
            DCEI.SetHorizontalOffsetInParent(descText, 45)
            DCEI.SetVerticalOffsetInParent(descText, -1*yPos)
            
            --DCEI.SetHorizontalOffsetInParent(descText, 75)
            DCEI.SetMaxSize(descText, 450, BUTTON_Y)
            --DCEI.SetLeftAlignmentInParent(descText)
            DCEI.SetTextFontSize(descText, 12)]]

            local titleText = DCEI.NewText(iconStack)
            DCEI.SetText(titleText, heroOption.name)
            
            
            DCEI.SetLeftAlignmentInParent(titleText)
            DCEI.SetHorizontalOffsetInParent(titleText, 55)
            --DCEI.SetVerticalOffsetInParent(titleText, 30)

            

            if(heroOption.image == "lock") then
                DCEI.EnableButton(button, false)
            end
        end
        
        
        
        
    end
    --[[local goldIconFrame = DCEI.NewFrame(padding)
    DCEI.SetLeftAlignmentInParent(goldIconFrame)
    DCEI.SetHorizontalOffsetInParent(goldIconFrame, 20)
    DCEI.SetVerticalOffsetInParent(goldIconFrame, 2)
    DCEI.SetBackgroundImage(goldIconFrame, "icon_coin00")
    DCEI.SetMinSize(goldIconFrame, 35, 35)
    DCEI.SetMaxSize(goldIconFrame, 35, 35)

    ]]


    
    return {
        frame = container,
    }
end


local inspectDialog = nil

function ClearInspectDialog()
    DCEI.Destroy(inspectDialog)
end

function CreateInspectUnitDialog(unitLink)
    local DIALOG_X = 200
    local DIALOG_Y = 65
    DCEI.LogMessage("Creating inspect unit dialog for unit: "..DCEI.UnitName(unitLink))
    if(inspectDialog ~= nil) then
        DCEI.Destroy(inspectDialog)
    end
    local container = DCEI.NewFrame(root)
    inspectDialog = container
    --DCEI.SetTopAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)

    local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(padding, "frame_inner_dark_grey")
    DCEI.SetMinSize(padding, DIALOG_X, DIALOG_Y)
    DCEI.SetMaxSize(padding, DIALOG_X, DIALOG_Y)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 150 / 255)
    --DCEI.SetTextColor(padding,255,0,0)
    local text = DCEI.NewText(padding)
    DCEI.SetText(text, "<color=#56D9FF>"..DCEI.UnitName(unitLink))
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -5)
    DCEI.SetTextFontSize(text, 12)

    text = DCEI.NewText(padding)
    DCEI.SetText(text, GetUnitDescription(unitLink))
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -23)
    DCEI.SetTextFontSize(text, 11)
    DCEI.SetMaxSize(text, DIALOG_X-15, DIALOG_Y-10)

    local attachOptions = {
        offset = {
            up = .85,
            right = 0,
            front = 0
        }

    }
    DCEI.AttachToUnit(container,unitLink,attachOptions)

    return {
        frame = container,
    }
end

local hexDialog = {}
local hexIcon = {}
function CreateHexUnit(unitLink,index)
    local DIALOG_X = 90
    local DIALOG_Y = 105
    --local randomX = GetRandomNumber(-20,20)
    --local randomY = GetRandomNumber(-20,20)
    --DCEI.LogMessage("Creating hex on unit: "..DCEI.UnitName(unitLink).."w/Pos: "..randomX..","..randomY)
    local container = DCEI.NewFrame(root)
    DCEI.SetHorizontalOffsetInParent(container, 0)
    hexDialog[index] = container
    

    local padding = DCEI.NewFrame(container)
    hexIcon[index] = padding
    DCEI.SetBackgroundImage(padding, "hex")
    DCEI.SetMinSize(padding, DIALOG_X, DIALOG_Y)
    DCEI.SetMaxSize(padding, DIALOG_X, DIALOG_Y)
    DCEI.SetHorizontalOffsetInParent(padding, 0 )
    DCEI.SetVerticalOffsetInParent(padding, 0)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 165 / 255)

    --local debugText = DCEI.NewText(padding)
    --DCEI.SetText(debugText, ""..index )

    local attachOptions = {
        offset = {
            up = 0,
            right = 0,
            front = 0
        }
    }
    DCEI.AttachToUnit(container, unitLink, attachOptions)

end

local dangerZones = {}
function UpdateHexGrid()
    for index=1,21 do
        if(TableContains(occupiedHexs,index) == true) then
            SetHexGridState(index,"Occupied")
            --DCEI.LogMessage("Setting Hex Grid: "..index.." as occupied!")
        elseif(TableContains(dangerZones,index) == true) then
            SetHexGridState(index,"DangerZone")
        else
            SetHexGridState(index,"Normal")
        end
    end
end


function SetHexGridState(index, state)
    if(state == "Occupied") then
        DCEI.SetBackgroundImage(hexIcon[index], "hexPurple")
    elseif(state == "Unavailable") then
        DCEI.SetBackgroundImage(hexIcon[index], "hexRed")
    elseif(state == "DangerZone") then
        DCEI.SetBackgroundImage(hexIcon[index], "hexRed")
    else
        DCEI.SetBackgroundImage(hexIcon[index], "hex")
    end
end

function ToggleHexGrid(state)
    --DCEI.LogMessage("Toggle hex grid called!")
    for index=1,21 do
        DCEI.SetActive(hexDialog[index],state) 
    end
    UpdateHexGrid()
end

local castBarID = 0
local castBars = {}
local blockFrame = {}
local buffFrame = {}
local buffStackFrame = {}
function CreateUnitBar(targetUnit, isEnemy)
    local container = DCEI.NewFrame(root)
    castBarID = castBarID + 1
    --local isEnemy = IsHeroUnit(targetUnit) == false
    local unitID = tostring(targetUnit)
    local dialogX = 80
    if(isEnemy) then dialogX = 55 end
    local dialogY = 11
    local dialogOpacity = 150/255
    local padding = DCEI.NewFrame(container)
    local barBackground = DCEI.NewFrame(padding)
    local image = {
        empty = "bar_exp01_empty",
        fill = "bar_exp01_fill",
        shield = "bar_exp01_fill_blue"
    }
    DCEI.SetBackgroundImage(barBackground, image.empty)
    DCEI.SetBottomAlignmentInParent(barBackground, 0)
    DCEI.SetSize(barBackground, dialogX, dialogY)
    DCEI.SetBackgroundImageColor(barBackground, 246, 225, 87, dialogOpacity)
    DCEI.SetVerticalOffsetInParent(barBackground, 40)

    local shieldFillBar = DCEI.NewFrame(barBackground)
    DCEI.SetBackgroundImage(shieldFillBar, image.shield)
    DCEI.SetSize(shieldFillBar, dialogX-0, dialogY-2)
    DCEI.SetBackgroundImageColor(shieldFillBar, 246, 225, 87, dialogOpacity)
    DCEI.SetBackgroundImageFillHorizontal(shieldFillBar)

    DCEI.TriggerAddTimerEventElapsed(function()
        UpdateShieldBar(shieldFillBar,targetUnit)
    end,0.1)

    local healthFillBar = DCEI.NewFrame(barBackground)
    DCEI.SetBackgroundImage(healthFillBar, image.fill)
    DCEI.SetSize(healthFillBar, dialogX-0, dialogY-2)
    DCEI.SetBackgroundImageColor(healthFillBar, 246, 225, 87, dialogOpacity)
    if(isEnemy) then
        DCEI.SetBackgroundImageColor(healthFillBar, 255/255, 26/255, 26/255, dialogOpacity)
    end
    DCEI.SetBackgroundImageFillHorizontal(healthFillBar)
    local identifier = DCEI.UnitName(targetUnit).."_"..(castBarID)
    DCEI.SetBackgroundImageFillAmountExpression(healthFillBar,identifier .. ".Health.Fraction")
    --DCEI.SetBackgroundImageFillAmount(healthFillBar, 0.0)
    local attachOptions = {
        offset = {
            up = 0.40,
            right = 0.03,
            front = 0
        }
    }
    if(isEnemy) then
        attachOptions.offset.up = 0.20
    end

    if(isEnemy == false) then
        local energyFillBar = DCEI.NewFrame(healthFillBar)
        DCEI.SetBackgroundImage(energyFillBar, image.shield)
        DCEI.SetSize(energyFillBar, dialogX-0, dialogY-4)
        DCEI.SetBackgroundImageColor(energyFillBar, 51/255, 204/255, 255/255, dialogOpacity)
        DCEI.SetBackgroundImageFillHorizontal(energyFillBar)
        DCEI.SetVerticalOffsetInParent(energyFillBar,-6)
        local e_identifier = DCEI.UnitName(targetUnit).."_"..(castBarID)
        DCEI.SetBackgroundImageFillAmountExpression(energyFillBar,e_identifier .. ".Mana.Fraction")
    end
    

    local identifier = DCEI.UnitName(targetUnit).."_"..(castBarID)
    DCEI.SetBackgroundImageFillAmountExpression(healthFillBar,identifier .. ".Health.Fraction")

    DCEI.AttachToUnit(container,targetUnit,attachOptions)
    DCEI.BindUnit(identifier,targetUnit)
    castBars[unitID] = container
    local opacityMod = 1
    local stackBuffFontSize = 14
    local createBuffBar = function ()
        local stack = DCEI.NewHStack(padding)
        DCEI.SetBackgroundImage(stack, "bar_exp00_empty")
        DCEI.SetBackgroundImageColor(stack, 1, 1, 1, 0)
        DCEI.SetSize(stack, dialogX, dialogY*2)
        --DCEI.SetMaxSize(stack, dialogX, dialogY)
        DCEI.SetBottomAlignmentInParent(stack)
        DCEI.SetVerticalOffsetInParent(stack,15)
        DCEI.SetSpacing(stack,0)
        DCEI.SetPadding(stack, 0)
        --DCEI.SetVerticalOffsetInParent(stack,)
        DCEI.SetCenterAlignment(stack)
        buffFrame[unitID] = {}
        buffStackFrame[unitID] = {}
        local mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImageColor(mobileBehavior, 1, 1, 1, opacityMod)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")
        DCEI.SetCenterAlignment(mobileBehavior)
        DCEI.SetCenterAlignmentInParent(mobileBehavior)
        buffFrame[unitID][1] = mobileBehavior

        local stackCountText = DCEI.NewText(mobileBehavior)
        DCEI.SetText(stackCountText,"1")
        DCEI.SetTextFontSize(stackCountText,stackBuffFontSize)
        DCEI.SetSize(stackCountText,20,20)
        buffStackFrame[unitID][1] = stackCountText

        mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImageColor(mobileBehavior, 1, 1, 1, opacityMod)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")
        buffFrame[unitID][2] = mobileBehavior

        stackCountText = DCEI.NewText(mobileBehavior)
        DCEI.SetText(stackCountText,"1")
        DCEI.SetTextFontSize(stackCountText,stackBuffFontSize)
        DCEI.SetSize(stackCountText,20,20)
        buffStackFrame[unitID][2] = stackCountText
    
        mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetBackgroundImageColor(mobileBehavior, 1, 1, 1, opacityMod)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")
        buffFrame[unitID][3] = mobileBehavior

        stackCountText = DCEI.NewText(mobileBehavior)
        DCEI.SetText(stackCountText,"1")
        DCEI.SetTextFontSize(stackCountText,stackBuffFontSize)
        DCEI.SetSize(stackCountText,20,20)
        buffStackFrame[unitID][3] = stackCountText

        mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetBackgroundImageColor(mobileBehavior, 1, 1, 1, opacityMod)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")
        buffFrame[unitID][4] = mobileBehavior

        stackCountText = DCEI.NewText(mobileBehavior)
        DCEI.SetText(stackCountText,"1")
        DCEI.SetTextFontSize(stackCountText,stackBuffFontSize)
        DCEI.SetSize(stackCountText,20,20)
        buffStackFrame[unitID][4] = stackCountText
        --[[
        mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")
    
        mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")
    
        mobileBehavior = DCEI.NewFrame(stack)
        DCEI.SetSize(mobileBehavior,20,20)
        DCEI.SetBackgroundImage(mobileBehavior,"icon_enhance_frosttower_tempestaura")]]
    
    
    end
    
    --ExecuteAfter(createBuffBar,0.5)

    local blockIcon = DCEI.NewFrame(healthFillBar)
    DCEI.SetBackgroundImage(blockIcon, "icon_shield")
    DCEI.SetSize(blockIcon, 25, 25)
    DCEI.SetLeftAlignmentInParent(blockIcon)
    DCEI.SetHorizontalOffsetInParent(blockIcon,-19)

    local blockText = DCEI.NewText(blockIcon)
    DCEI.SetTextFontSize(blockText, 18)
    DCEI.SetSize(blockText, 25,25)
    DCEI.SetText(blockText,"5")
    DCEI.SetHorizontalOffsetInParent(blockText,-1)

    blockFrame[unitID] = {}
    blockFrame[unitID].icon = blockIcon
    blockFrame[unitID].text = blockText

    DCEI.TriggerAddTimerEventElapsed(function()
        UpdateBlockBar(targetUnit)
    end,0.1)
    createBuffBar()
    UpdateBuffBar(targetUnit)
end

function UpdateBuffBar(unit)

    local id = tostring(unit)
    local buffsToShow = {}
    local buffCounts = {}
    if(buffFrame[id] == nil) then return end
    foreach(displayBehaviors, function(behavior)
        local count = DCEI.UnitBehaviorStackCount(unit, behavior.name)
        if(count > 0) then
            table.insert(buffsToShow,behavior)
            table.insert(buffCounts,count)
        end
    end)
    local numBuffs = GetTableSize(buffsToShow)
    for index=1,4 do
        local buffIcon = buffFrame[id][index]
        if(index <= numBuffs) then
            DCEI.SetActive(buffFrame[id][index],true)
            DCEI.SetBackgroundImage(buffFrame[id][index],buffsToShow[index].image)
            DCEI.SetTooltipText(buffFrame[id][index],buffsToShow[index].description)
            if(buffsToShow[index].stacks == true) then
                DCEI.SetText(buffStackFrame[id][index],buffCounts[index])
            else
                DCEI.SetText(buffStackFrame[id][index],"")
            end
        else
            DCEI.SetActive(buffFrame[id][index],false)
        end
    end
end

function UpdateBlockBar(targetUnit)
    local unitID = tostring(targetUnit)
    if(UnitIsAlive(targetUnit) == false) then
        DCEI.Destroy(castBars[unitID])
        return 
    end
    --DCEI.LogMessage("Updating Block Bar on unit: "..DCEI.UnitName(targetUnit))
    local block = DCEI.UnitBehaviorStackCount(targetUnit,"Block")
    if(block > 0) then
        DCEI.SetActive(blockFrame[unitID].icon,true)
        DCEI.SetText(blockFrame[unitID].text,block)
    else
        DCEI.SetActive(blockFrame[unitID].icon,false)
    end

    ExecuteAfter(function()
        UpdateBlockBar(targetUnit)
    end,1)
    
end

function UpdateShieldBar(bar, unitLink)
    if(bar ~= nil and UnitIsAlive(unitLink)) then
        local shieldAmt = DCEI.GetShieldValue(unitLink)
        if(shieldAmt ~= nil and shieldAmt > 1) then
            DCEI.SetBackgroundImageFillAmount(bar, ( (DCEI.GetHealthValue(unitLink)+ shieldAmt)/DCEI.GetMaxHealth(unitLink)))
            
        else
            DCEI.SetBackgroundImageFillAmount(bar, 0.0)
        end
        ExecuteAfter(function()
            UpdateShieldBar(bar,unitLink)
        end,0.2)
        
        

    end
    
end

function RemoveAllCastbars()
    foreach(castBars, function(bar)
        DCEI.Destroy(bar)
    end)
end

local castID = 0
function CreateUnitCastBar(castingUnit, spellName, timeToFill, castCallback)
    if(DCEI.UnitBehaviorStackCount(castingUnit,"Paused") > 0 or battleOngoing == false) then
        return
    end
    local container = DCEI.NewFrame(root)
    local dialogX = 100
    local dialogY = 9
    castID = castID + 1
    --DCEI.SetTopAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)
    local image = {
        empty = "health_bar_boss_special",
        fill = "health_bar_boss_special_fill"
    }
    local padding = DCEI.NewFrame(container)
    --DCEI.SetBottomAlignmentInParent(padding, 0)
    local barBackground = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(barBackground, image.empty)
    DCEI.SetBottomAlignmentInParent(barBackground, 0)
    DCEI.SetMinSize(barBackground, dialogX, dialogY)
    DCEI.SetBackgroundImageColor(barBackground, 246, 225, 87, 180)
    DCEI.SetVerticalOffsetInParent(barBackground, 35)

    local castBarFillBar = DCEI.NewFrame(barBackground)
    DCEI.SetBackgroundImage(castBarFillBar, image.fill)
    --DCEI.SetBottomAlignmentInParent(barBackground, 0)
    DCEI.SetMinSize(castBarFillBar, dialogX, dialogY)
    DCEI.SetBackgroundImageColor(castBarFillBar, 246, 225, 87, 180)
    
    DCEI.SetBackgroundImageFillAmount(castBarFillBar, 0.0)
    local attachOptions = {
        offset = {
            up = 0.55,
            right = 0,
            front = 0
        }
    }
    DCEI.AttachToUnit(container,castingUnit,attachOptions)
    local createdUnit = DCEI.CreateUnit(1,1,"DummyFillUnit",0,0)
    local identifier = "dummyFillUnit_"..castID
    DCEI.SetBackgroundImageFillAmountExpression(castBarFillBar, identifier .. ".Mana.Fraction")
    DCEI.BindUnit(identifier, createdUnit)

    local castBarText = DCEI.NewText(castBarFillBar)
    DCEI.SetText(castBarText, ""..spellName)
    DCEI.SetTextFontSize(castBarText, 16)
    DCEI.SetVerticalOffsetInParent(castBarText,20)
    local PRECAST_TIME = 0.75
    DCEI.AnimateAlpha(container,0,1,PRECAST_TIME,"OutSine")
    DCEI.TriggerAddTimerEventElapsed(function()
        local success = UpdateCastBar(castingUnit,createdUnit,timeToFill)
        if(success) then
            DCEI.TriggerAddTimerEventElapsed(function()
                castCallback()
                DCEI.AnimateAlpha(container,1,0,PRECAST_TIME,"OutSine")
                DCEI.Wait(PRECAST_TIME)
                DCEI.Destroy(container)
            end,.1,true)
        else
            --The casting failed and was interrupted.
            DCEI.SetText(castBarText, "<color=red>INTERRUPTED!")
            DCEI.AnimateAlpha(container,1,0,1+PRECAST_TIME,"OutSine")
            DCEI.Wait(1+PRECAST_TIME)
            DCEI.Destroy(container)
        end
        
    end,PRECAST_TIME,true)
    
end

function UpdateCastBar(castingUnitLink,castFillDummyUnit,totalTime)
    DCEI.SetManaValue(castFillDummyUnit,progress)
    local progress = 0.0
    local TICK_RATE = 0.05 --How often (in seconds) the castbar updates its fill value.
    local progressPerTick =  (100 / totalTime) * TICK_RATE
    while(progress < 100 and CanCast(castingUnitLink) == true) do
        
        progress = progress + progressPerTick
        DCEI.SetManaValue(castFillDummyUnit,progress)
        --DCEI.SetBackgroundImageFillAmount(castFillBar, progress)
        DCEI.Wait(TICK_RATE)
    end
    if(progress >= 100) then
        return true
    else
        return false
    end
    
end

function CanCast(unitLink) 
    return  unitLink ~= nil and UnitIsAlive(unitLink) and DCEI.UnitBehaviorStackCount(unitLink, "Stun") <= 0 and battleOngoing == true
end

local powerBarText = nil
local powerBarFillBar = nil

function CreatePowerBar()
    local container = DCEI.NewFrame(inventoryDialog)
    local dialogX = 510
    local dialogY = 30
    --DCEI.SetTopAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)
    local image = {
        empty = "powerBarBackground",
        fill = "powerBarFill"
    }
    local padding = DCEI.NewFrame(container)
    DCEI.SetBottomAlignmentInParent(padding, 0)
    local barBackground = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(barBackground, image.empty)
    DCEI.SetBottomAlignmentInParent(barBackground, 0)
    DCEI.SetMinSize(barBackground, dialogX, dialogY)
    DCEI.SetBackgroundImageColor(barBackground, 246, 225, 87, 255)
    DCEI.SetVerticalOffsetInParent(barBackground, 35)

    powerBarFillBar = DCEI.NewFrame(barBackground)
    DCEI.SetBackgroundImage(powerBarFillBar, image.fill)
    --DCEI.SetBottomAlignmentInParent(barBackground, 0)
    DCEI.SetMinSize(powerBarFillBar, dialogX, dialogY)
    DCEI.SetBackgroundImageColor(powerBarFillBar, 246, 225, 87, 255)
    
    DCEI.SetTooltipText(powerBarFillBar,"As your team engages in combat, you earn team experience. Once this bar is full, you will be able to choose a perk for your team!")
    DCEI.SetTooltipText(barBackground,"As your team engages in combat, you earn team experience. Once this bar is full, you will be able to choose a perk for your team!")

    local identifier = "mainUnit"
    DCEI.SetBackgroundImageFillAmountExpression(powerBarFillBar, identifier .. ".Mana.Fraction")
    DCEI.BindUnit(identifier, ITEM_CASTER)

    powerBarText = DCEI.NewText(powerBarFillBar)
    DCEI.SetText(powerBarText, "Perk Available!")
    --DCEI.SetRightAlignmentInParent(goldIndicatorText)
    --DCEI.SetHorizontalOffsetInParent(goldIndicatorText, 90)
    DCEI.SetTextFontSize(powerBarText, 18)
    UpdatePowerBar()
    CheckPowerGains()
end

function CreateRelevantUnitText(unit, text)
    local options = { 
        offset = {
            up = 1.25,
            right = 0,
            front = 0
        }
    }
    DCEI.ShowFloatingText(DCEI.GetUnitPosition3D(unit),"<size=12>"..text,0.9,0,1,options )
end

function GetUnitHealthFraction(unit)
    --if(unit == nil) then return 0 end
    return (DCEI.GetHealthValue(unit) / DCEI.GetMaxHealth(unit))
end


function CheckPowerGains()
    if(battleOngoing == false) then return end
    local gainedPower = 2 + (recentElitesKilled * 20)
    recentElitesKilled = 0
    local options = { 
        offset = {
            up = .85,
            right = 0,
            front = 0
        }
    }
    local powerPerHero = 2.5
    if(PARTY_SIZE >= 4) then
        powerPerHero = (8 / PARTY_SIZE)
    end
    if(PARTY_SIZE == 2) then
        powerPerHero = 3
    end
    if(PARTY_SIZE == 1) then
        powerPerHero = 6
    end
    if(doublePower == true) then
        powerPerHero = powerPerHero * 2
    end
    foreach(party,function(hero)
        if(hero ~= nil and (DCEI.GetManaValue(hero) >= MANA_COST or (DCEI.UnitName(hero) == "Alchemist" and GetUnitHealthFraction(hero) >= 0.99))) then
            gainedPower = gainedPower + powerPerHero
            
            if(playerPower >= 100) then
                DCEI.ShowFloatingText(DCEI.GetUnitPosition3D(hero),"<size=12><color=#E98C00>XP Full!",0.7,0,1,options )
            else
                if(GetPerkCountByName("Powercharged") >= 1) then
                    DCEI.ApplyBehavior(hero, "Powercharged")
                end
                
                if(DCEI.UnitName(hero) == "Priest" and GetPerkCountByName("Light's Boon") >= 1) then
                    HealUnit(hero,6,"Healing!")
                else
                    DCEI.ShowFloatingText(DCEI.GetUnitPosition3D(hero),"<size=12><color=#7F58C7>+ Team XP",0.7,0,1,options )
                end
                
            end
            
        end
    end)
    
    --playerPower = playerPower + gainedPower
    local timeToChange = 2.99
    for powerIndex=1,gainedPower do
        if(battleOngoing == false) then
            return
        end
        SetPlayerPower(playerPower+1)
        DCEI.Wait(timeToChange/gainedPower)
    end
    
end

function SetPlayerPower(newValue)
    local oldPower = playerPower
    playerPower = newValue
    DCEI.SetManaValue(ITEM_CASTER, newValue)
    UpdatePowerBar()
    if(oldPower < 100 and playerPower >= 100) then
        PlaySound("[Sound] Perk Earned")
    end
end

function UpdatePowerBar()
    --DCEI.SetBackgroundImageFillAmount(powerBarFillBar, (playerPower/100))
    if(playerPower < 100) then
        DCEI.SetText(powerBarText, "Team XP: ".. math.floor(playerPower).." %")
    else
        DCEI.SetText(powerBarText, "Team Perk Available!")
    end
    
end

local goldIndicatorText = nil
function CreateGoldPanel()
    local container = DCEI.NewFrame(root)
    DCEI.SetBottomAlignmentInParent(container)
    DCEI.SetRightAlignmentInParent(container)
    DCEI.SetHorizontalOffsetInParent(container, 0)
    DCEI.SetVerticalOffsetInParent(container, 0)

    local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(padding, "frame07")

    DCEI.SetSize(padding, 175, 50)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 200 / 255)
    local goldIconFrame = DCEI.NewFrame(padding)
    DCEI.SetLeftAlignmentInParent(goldIconFrame)
    DCEI.SetHorizontalOffsetInParent(goldIconFrame, 20)
    DCEI.SetVerticalOffsetInParent(goldIconFrame, 2)
    DCEI.SetBackgroundImage(goldIconFrame, "icon_coin00")
    DCEI.SetMinSize(goldIconFrame, 35, 35)
    DCEI.SetMaxSize(goldIconFrame, 35, 35)
    DCEI.SetTooltipText(goldIconFrame,"Represents your gold.")

    goldIndicatorText = DCEI.NewText(goldIconFrame)
    DCEI.SetText(goldIndicatorText, "100")
    DCEI.SetRightAlignmentInParent(goldIndicatorText)
    DCEI.SetHorizontalOffsetInParent(goldIndicatorText, 90)
    DCEI.SetTextFontSize(goldIndicatorText, 25)


    
    return {
        frame = container,
    }
end

function UpdateGoldPanel()
    DCEI.SetText(goldIndicatorText, ""..math.floor(playerGold))
end

function GetRandomEvent()
    local eventToShow = GetRandomElement(gameEvents)
    if(TableContains(displayedEvents, eventToShow) == true) then
        eventToShow = GetRandomElement(gameEvents)
    end
    if(TableContains(displayedEvents, eventToShow) == true) then
        eventToShow = GetRandomElement(gameEvents)
    end
    if(TableContains(displayedEvents, eventToShow) == true) then
        eventToShow = GetRandomElement(gameEvents)
    end
    return eventToShow
end

local eventPanel = nil
function ShowEvent(eventToShow)
    if(eventPanel ~= nil) then
        DCEI.Destroy(eventPanel)
    end
    table.insert(displayedEvents, eventToShow)
    
    ToggleMapFrame(false)
    local container = DCEI.NewFrame(root)
    eventPanel = container


    local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(padding, "frame_dark_stroke")
    DCEI.SetMinSize(padding, 520, 425)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 220 / 255)
    DCEI.SetHorizontalOffsetInParent(padding, 10)


    local textBG = DCEI.NewFrame(padding)
    DCEI.SetSize(textBG,500,90)
    DCEI.SetTopAlignmentInParent(textBG)
    DCEI.SetVerticalOffsetInParent(textBG, -45)
    DCEI.SetBackgroundImage(textBG, "frame_dark_stroke")
    DCEI.SetBackgroundImageColor(textBG, 246, 225, 87, 75 / 255)

    local text = DCEI.NewText(padding)
    DCEI.SetText(text, "<color=yellow>"..eventToShow.name)
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, 0)
    DCEI.SetTextFontSize(text, 25) 
    DCEI.SetSize(text,475,50)

    
    text = DCEI.NewText(textBG)
    DCEI.SetText(text, "<color=#e0e0e0>"..eventToShow.description)
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, 0)
    DCEI.SetTextFontSize(text, 18)
    DCEI.SetSize(text,475,90)

    local eventChoices = 2
    if(eventToShow.choices[3] ~= nil and eventToShow.choiceDescriptions[3] ~= nil) then
        eventChoices = 3
    end
    if(eventToShow.choices[2] == nil or eventToShow.choiceDescriptions[2] == nil) then
        eventChoices = 2
    end


    local image = DCEI.NewFrame(padding)
    DCEI.SetSize(image,500,155)
    --DCEI.SetTopAlignmentInParent(image)
    DCEI.SetVerticalOffsetInParent(image, -10)
    DCEI.SetBackgroundImage(image, "placeholder")
    DCEI.SetBackgroundImageColor(image, 246, 225, 87, 65 / 255)

    local spacing = 20
    if(eventChoices == 2) then
        spacing = 40
    end
    local baseX = 540
    if(eventChoices == 3) then
        baseX = baseX - 20
    end
    local buttonX = (baseX - (spacing * eventChoices))/eventChoices
    local buttonY = 100
    local stack = DCEI.NewHStack(padding)
    DCEI.SetSize(stack,500,buttonY)
    DCEI.SetBottomAlignmentInParent(stack)
    DCEI.SetBackgroundImage(stack, "frame_dark_stroke")
    DCEI.SetVerticalOffsetInParent(stack,18)
    DCEI.SetBackgroundImageColor(stack, 235/255, 219/255, 80/255, 25 / 255)
    --DCEI.LogMessage("Got "..eventChoices.." events for eventname:"..eventToShow.name)
    DCEI.SetSpacing(stack,spacing)
    local images = {"btn_yellow_pressed","btn_yellow"}
    for buttonID=1,eventChoices do
        local button = DCEI.NewButton(stack)
        DCEI.SetBackgroundImage(button, images[(buttonID % 2) + 1])
        DCEI.SetSize(button,buttonX,buttonY)

        text = DCEI.NewText(button)
        DCEI.SetText(text, ""..eventToShow.choices[buttonID])
        --DCEI.SetTopAlignmentInParent(text)
        DCEI.SetVerticalOffsetInParent(text, 0)
        --DCEI.SetTextFontSize(text, 22)
        DCEI.SetTextFontSizeMax(text,22)
        DCEI.SetTextFontSizeMin(text,15)
        DCEI.SetSize(text,buttonX-20,buttonY-15)
        DCEI.SetTooltipText(button,HighlightKeywords(eventToShow.choiceDescriptions[buttonID]))
        DCEI.SetOnClickCallback(button, function()
            DCEI.SetTooltipText(button,"")
            DCEI.Destroy(eventPanel)
            
            eventToShow.choiceCallbacks[buttonID]()
            if(battleOngoing == false) then
                OnShoppingEnded()
            end
            
        end)
    end
end


local mapRoomButtons = {}
local mapRoomHighlightButtons = {}
local mapRoomPropertyIndicator = {}
local currentRoomIndicator = nil
local mapFrame = nil
local threatPanelText = nil
local areaPanelText = nil
local BUTTON_X = 50
local BUTTON_Y = 50
local OFFSET = 15
local INITIAL_OFFSETX = -117
local INITIAL_OFFSETY = 20
function CreateMapPanel(floorID)
    if(mapFrame ~= nil) then
        DCEI.Destroy(mapFrame)
        mapRoomButtons = {}
        mapRoomHighlightButtons = {}
        mapRoomPropertyIndicator = {}
        currentRoomIndicator = nil
        threatPanelText = nil
        areaPanelText = nil
    end
    DCEI.LogMessage("Generating map Floor:"..floorID)
    currentFloor = floorID
    local validRooms = GenerateMap(floorID)
    map = validRooms
    local container = DCEI.NewFrame(root)
    mapFrame = container
    --DCEI.SetBottomAlignmentInParent(container)
    --DCEI.SetRightAlignmentInParent(container)
    --DCEI.SetHorizontalOffsetInParent(container, 0)
    --DCEI.SetVerticalOffsetInParent(container, 45)

    local padding = DCEI.NewFrame(container)
    DCEI.SetBackgroundImage(padding, "frame_dark_stroke")
    DCEI.SetMinSize(padding, 340, 400)
    DCEI.SetBackgroundImageColor(padding, 246, 225, 87, 120 / 255)
    DCEI.SetHorizontalOffsetInParent(padding, 10)

    local text = DCEI.NewText(padding)
    areaPanelText   = text
    
    DCEI.SetText(text, "<color=red>Threat Level: None")
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -12)
    DCEI.SetTextFontSize(text, 20) 
    
    text = DCEI.NewText(padding)
    threatPanelText = text
    DCEI.SetText(text, "Area: 1/3")
    DCEI.SetTopAlignmentInParent(text)
    DCEI.SetVerticalOffsetInParent(text, -40)
    DCEI.SetTextFontSize(text, 17)

    --Legend Panel
    local legendPanel = DCEI.NewFrame(padding)
    DCEI.SetBackgroundImage(legendPanel, "frame_dark_stroke")
    DCEI.SetLeftAlignmentInParent(legendPanel)
    DCEI.SetSize(legendPanel, 200, 375)
    DCEI.SetHorizontalOffsetInParent(legendPanel, -210)
    DCEI.SetBackgroundImageColor(legendPanel, 246, 225, 87, 120 / 255)

    local legendTitle = DCEI.NewText(legendPanel)
    DCEI.SetText(legendTitle, "Choose a highlighted room to move to it!\n\nTo see more info about a room, mouse over it.")
    DCEI.SetMaxSize(legendTitle,180, 355)
    --DCEI.SetTopAlignmentInParent(legendTitle)
    DCEI.SetVerticalOffsetInParent(legendTitle, 20)
    DCEI.SetTextFontSize(legendTitle, 18)

    


    local columns = 5
    local rows = 5
    
    local roomID = 1
    for colID = 1, columns do
        for rowID = 1, rows do
            if(DoesRoomExist(roomID) == false) then
                --DCEI.LogMessage("Room ID: "..roomID.." does not exist. Map size: "..GetTableSize(map))
            end
            if(rowID ~= rows and DoesRoomExist(roomID) and DoesRoomExist(GetRoomInDirection(roomID,"Right"))) then
                
                local xPos = INITIAL_OFFSETX + ((OFFSET + BUTTON_X) * (rowID - 1))
                local yPos = INITIAL_OFFSETY + ((OFFSET + BUTTON_Y) * (colID - 1))
                local connector = DCEI.NewButton(container)
                DCEI.SetMinSize(connector, BUTTON_X+11, 10)
                DCEI.SetMaxSize(connector, BUTTON_X+11, 10)
                DCEI.SetBottomAlignmentInParent(connector)
                DCEI.SetHorizontalOffsetInParent(connector, xPos+(BUTTON_X*0.7))
                DCEI.SetVerticalOffsetInParent(connector, yPos + (BUTTON_Y*0.4))
                DCEI.SetBackgroundImage(connector, "frame05_fill")
            end
            if(colID ~= columns and DoesRoomExist(roomID) and DoesRoomExist(GetRoomInDirection(roomID,"Up"))) then
                local xPos = INITIAL_OFFSETX + ((OFFSET + BUTTON_X) * (rowID - 1))
                local yPos = INITIAL_OFFSETY + ((OFFSET + BUTTON_Y) * (colID - 1))
                local connector = DCEI.NewButton(container)
                DCEI.SetMinSize(connector, 10, BUTTON_X+11)
                DCEI.SetMaxSize(connector, 10, BUTTON_X+11)
                DCEI.SetBottomAlignmentInParent(connector)
                DCEI.SetHorizontalOffsetInParent(connector, xPos)
                DCEI.SetVerticalOffsetInParent(connector, yPos + (BUTTON_Y*0.4) )
                DCEI.SetBackgroundImage(connector, "frame05_fill")
            end
            roomID = roomID + 1
        end
    end
    roomID = 1
    
    for colID = 1, columns do
        for rowID = 1, rows do
            if(TableContains(validRooms, roomID) == true) then
                local imagePath = "icon_enhance_arrowtower_huntersmark"
                local xPos = INITIAL_OFFSETX + ((OFFSET + BUTTON_X) * (rowID - 1))
                local yPos = INITIAL_OFFSETY + ((OFFSET + BUTTON_Y) * (colID - 1))
            
                --[[local bgButton = DCEI.NewFrame(container)
                mapRoomHighlightButtons[roomID] = bgButton
                local myXPos = xPos --+ 6
                local myYPos = yPos --+ 6
                DCEI.SetBackgroundImage(bgButton, "glowMapButton")
                DCEI.SetBottomAlignmentInParent(bgButton)
                DCEI.SetVerticalOffsetInParent(bgButton, myYPos)
                DCEI.SetHorizontalOffsetInParent(bgButton, myXPos)
                DCEI.SetSize(bgButton, BUTTON_X+5, BUTTON_Y+5)]]

                local button = DCEI.NewButton(container)
                mapRoomButtons[roomID] = button
                if(GetRoomType(roomID) == "Shop") then
                    imagePath = "icon_ingame_towerslot_potiondealer"
                end
                
                --DCEI.LogMessage("Creating Loot Button: "..roomID.." at xPos: "..xPos)
                DCEI.SetBackgroundImage(button, imagePath)
                DCEI.SetBottomAlignmentInParent(button)
                DCEI.SetVerticalOffsetInParent(button, yPos)
                DCEI.SetHorizontalOffsetInParent(button, xPos)
                DCEI.SetMinSize(button, BUTTON_X, BUTTON_Y)
                DCEI.SetMaxSize(button, BUTTON_X, BUTTON_Y)
                
                DCEI.SetOnClickCallback(button, 
                function()
                    DCEI.SetTooltipText(button,"")
                    --DCEI.Wait(.1)
                    GotoRoom(button)
                end)

                if(currentRoom == roomID) then
                    --[[currentRoomIndicator = DCEI.NewFrame(container)
                    DCEI.SetMinSize(currentRoomIndicator, BUTTON_X, BUTTON_Y)
                    DCEI.SetMaxSize(currentRoomIndicator, BUTTON_X, BUTTON_Y)
                    DCEI.SetBottomAlignmentInParent(currentRoomIndicator)
                    DCEI.SetHorizontalOffsetInParent(currentRoomIndicator, xPos)
                    DCEI.SetVerticalOffsetInParent(currentRoomIndicator, yPos )
                    DCEI.SetBackgroundImage(currentRoomIndicator, "frame_border_gold")
                    DCEI.SetBackgroundImageColor(currentRoomIndicator, 246, 225, 87, 120 / 255)]]
                end


                
                local bgButton = DCEI.NewFrame(container)
                mapRoomHighlightButtons[roomID] = bgButton
                xPos = xPos + 0
                yPos = yPos + 2
                DCEI.SetBackgroundImage(bgButton, "glowMapButton")
                DCEI.SetBottomAlignmentInParent(bgButton)
                DCEI.SetVerticalOffsetInParent(bgButton, yPos)
                DCEI.SetHorizontalOffsetInParent(bgButton, xPos)
                DCEI.SetSize(bgButton, BUTTON_X-1, BUTTON_Y-3)

                local borderHighlight = DCEI.NewHighlight(button)
                mapRoomPropertyIndicator[roomID] = borderHighlight
                DCEI.SetSize(borderHighlight,BUTTON_X,BUTTON_Y)
                DCEI.SetBackgroundImageColor(borderHighlight,1,1,1,1)
                
        
            end
            
            
            --Room connecting UI
            

            roomID = roomID + 1
        end
        
        
        
        
        
    end
    ExploreRoom(currentRoom)
    if(floorID > 1) then
        OnRoomEnter(currentRoom)
    end
    --UpdateMapPanel()
    
    return {
        frame = container,
    }
end

function GetButtonPosition(roomButtonID)
    local colID = roomButtonID % 5
    local rowID = math.floor((roomButtonID / 5)+0.5)
    --[[if(roomButtonID % 5 ~= 0) then
        rowID = rowID + 1
    end]]
    DCEI.LogMessage("Got row ID:"..rowID.." and colID:"..colID.." for source room: "..roomButtonID)
    local xPos = INITIAL_OFFSETX + ((OFFSET + BUTTON_X) * (rowID - 1))
    local yPos = INITIAL_OFFSETY + ((OFFSET + BUTTON_Y) * (colID - 1))
    return {x=xPos,y=yPos}
end






local nightmareUpdating = false
local timesNightmareUpdated = 0
local recentlyConvertedNightmareRooms = {}
function HandleNightmareUpdate()
    recentlyConvertedNightmareRooms = {}
    nightmareUpdating = true
    local nightmarePasses = GetRandomNumber(1, 1+timesNightmareUpdated)
    ShowOverheadMessage("You are being pursued...",4.5,{74/255, 0/255,171/255, 255/255})
    DCEI.PlaySound("desecrate_impact")
    DCEI.Wait(1)
    --local nightmareRoomsMade = 0
    local coreStartRoom = 1
    for index=1,5 do
        if(DoesRoomExist(index) == true) then
            coreStartRoom = index
        end
    end
    for index=1,nightmarePasses do
        local roomsToConvert = DoNightmarePass(coreStartRoom)
        
        foreach(roomsToConvert, function(room)
        if(DoesRoomExist(room) and GetRoomType(room) ~= "Nightmare") then
            DCEI.LogMessage("Got room to convert: "..roomsToConvert[1])
            DCEI.PlaySound("evilwings_meteor_impact")
            SetRoomType(room,"Nightmare")
            table.insert(recentlyConvertedNightmareRooms,room)
            if(currentRoom ~= room) then
                DCEI.SetBackgroundImage(mapRoomButtons[room],"icon_enhance_darkspire_torment")
                DCEI.AnimateAlpha(mapRoomButtons[room], 0, 0.45, 0.5, "OutSine")
                ExecuteAfter(function()
                    DCEI.AnimateAlpha(mapRoomButtons[room], 0.45, 1, 0.8, "OutSine")
                end,0.5)
                DCEI.Wait(1.0)
            end
            
        end
        
        end)
        --DCEI.Wait(0.5)
    end
    
    nightmareUpdating = false
    timesNightmareUpdated = timesNightmareUpdated + 1
    UpdateMapPanel()
end


function DoNightmarePass(coreRoom)
    local roomsToConvert = {}
    if(GetRoomType(coreRoom) ~= "Nightmare") then
        table.insert(roomsToConvert,coreRoom)
        --SetRoomType(coreRoom,"Nightmare"
    else
        local nightmareRooms = GetRoomsOfType("Nightmare",0,25,{},map)
        
        foreach(nightmareRooms, function(room)
            local nearby = GetAllPossibleAdjacentRooms(room)
            foreach(nearby, function(nearRoom)
                if(GetRoomType(nearRoom) ~= "Nightmare" and GetRoomType(nearRoom) ~= "Stairs" and TableContains(recentlyConvertedNightmareRooms,nearRoom) == false) then
                    table.insert(roomsToConvert,nearRoom)
                end
            end)
        
        end)
    end
    DCEI.LogMessage("Got number of rooms to convert: "..GetTableSize(roomsToConvert))
    return roomsToConvert
end

function GetSpecialRoomCount()
    local count = 0
    foreach( specialRoomModifiers, function(modifier)
        if(modifier ~= nil and modifier ~= "None" ) then
            count = count + 1
            DCEI.LogMessage("Found special room of type: "..modifier)
        end
    end)
    DCEI.LogMessage("Got special room count: "..count)
    return count

end


function GetRandomCombatRoom()
    local possibleRooms = {}
    for index = 1, 25 do
        if(DoesRoomExist(index)) then
            if((GetRoomType(index) == "Combat" or GetRoomType(index) == "Elite") and HasRoomBeenVisited(index) == false and IsRoomExplored(index)) then
                
                table.insert( possibleRooms, index)
            end
        end
    end
    if(GetTableSize(possibleRooms) <= 0) then
        return -1
    end
    return GetRandomElement(possibleRooms)
end

function GetRandomSpecialRoomModifier()
    local possibleModifiers = {"PreparingOthers" , "AlertingOthers"}
    return GetRandomElement(possibleModifiers)
end

function HandleSpecialRoomEffects()
    nightmareUpdating = true
    local index = 1
    foreach(specialRoomModifiers, function(modifier)
        if(modifier == "AlertingOthers" and HasRoomBeenVisited(index) == false) then
            IncreasePlayerThreat(5)
            DCEI.AnimateAlpha(mapRoomButtons[index], 0, 0.45, 0.5, "OutSine")
            ExecuteAfter(function()
                DCEI.AnimateAlpha(mapRoomButtons[index], 0.45, 1, 0.8, "OutSine")
            end,0.5)
        end
        if(modifier == "PreparingOthers" and HasRoomBeenVisited(index) == false) then
            roomDifficulty[index] = roomDifficulty[index] + 1
            local adjacent = GetAllPossibleAdjacentRooms(index)
            foreach(adjacent, function(roomID)
                if(DoesRoomExist(roomID) and roomDifficulty[roomID] ~= nil) then
                    roomDifficulty[roomID] = roomDifficulty[roomID] + 1
                end
            end)
            ShowRelevantText("+ Encounter Difficulty")
            DCEI.AnimateAlpha(mapRoomButtons[index], 0, 0.45, 0.5, "OutSine")
            ExecuteAfter(function()
                DCEI.AnimateAlpha(mapRoomButtons[index], 0.45, 1, 0.8, "OutSine")
            end,0.5)
        end
        if(modifier ~= nil and modifier ~= "None") then
            DCEI.Wait(1)
        end
        
        index = index + 1
    end)

    nightmareUpdating = false
end

local mapFrameVisible = false
function ToggleMapFrame(state)
    mapFrameVisible = state
    
    for index = 1, 25 do
        if(DoesRoomExist(index)) then
            if((AreRoomsAdjacent(index, currentRoom) or index == currentRoom or IsRoomExplored(index)== false)) then
                DCEI.SetBackgroundImageGrayScale(mapRoomButtons[index], false)
                
                if(AreRoomsAdjacent(index, currentRoom)) then
                    --DCEI.LogMessage("Showing border indicator for room: "..index.." due to adjacency with current room.")
                    DCEI.SetActive(mapRoomPropertyIndicator[index], true)
                    DCEI.SetBackgroundImageColor(mapRoomPropertyIndicator[index],1,1,1,1)
                else
                    DCEI.SetActive(mapRoomPropertyIndicator[index], false)
                end
                
            else
                DCEI.SetBackgroundImageGrayScale(mapRoomButtons[index], true)
                if ((GetRoomType(index) == "Combat" or GetRoomType(index) == "Elite" ) and specialRoomModifiers[index] ~= "None")then
                    DCEI.SetBackgroundImageColor(mapRoomPropertyIndicator[index],1,0,0,1)
                    DCEI.SetActive(mapRoomPropertyIndicator[index], true)
                else
                    DCEI.SetActive(mapRoomPropertyIndicator[index], false)
                end
                
            end
            --DCEI.SetTooltipText(mapRoomButtons[index],"")
        end
    end
    
    DCEI.SetActive(mapFrame,state)
    UpdateMapVisibleLoop()
    
    

    
    --ClearTooltips()
end
local MAX_ALPHA = .5
local MIN_ALPHA = .1
function UpdateMapVisibleLoop()
    for index = 1, 25 do
        if(IsRoomExplored(index) == true and AreRoomsAdjacent(index, currentRoom) and HasRoomBeenVisited(index) == false) then
            DCEI.AnimateAlpha(mapRoomHighlightButtons[index],MAX_ALPHA,MAX_ALPHA,.1,"InSine")
            
        else
            
            DCEI.AnimateAlpha(mapRoomHighlightButtons[index],0,0,.1,"InSine")
        end
    end
end

function CheckMapVisibleLoop()
    
    if(mapFrameVisible == false) then return end
    for index = 1, 25 do
        if(IsRoomExplored(index) == true and AreRoomsAdjacent(index, currentRoom) and HasRoomBeenVisited(index) == false) then
            DCEI.AnimateAlpha(mapRoomHighlightButtons[index],MAX_ALPHA,MIN_ALPHA,1,"InSine")
        else
            DCEI.AnimateAlpha(mapRoomHighlightButtons[index],0,0,1,"InSine")
        end
    end
    DCEI.Wait(1)
    for index = 1, 25 do
        if(IsRoomExplored(index) == true and AreRoomsAdjacent(index, currentRoom) and HasRoomBeenVisited(index) == false) then
            DCEI.AnimateAlpha(mapRoomHighlightButtons[index],MIN_ALPHA,MAX_ALPHA,1,"OutSine")
        end
    end

end

function GotoRoom(targetRoomButton)
    local targetRoom = 0
    if(nightmareUpdating) then
        ShowErrorText("You can't do that right now!")
        return
    end
    for index = 1, 25 do
        if(mapRoomButtons[index] == targetRoomButton) then
            targetRoom = index
        end
    end
    DCEI.LogMessage("Attempting to goto room ID:"..targetRoom.."-- Which is a "..GetRoomType(targetRoom))
    
    if(battleOngoing == false and AreRoomsAdjacent(targetRoom,currentRoom)) then
        if(GetRoomType(targetRoom) == "Stairs") then
            if(currentFloor ~= currentDungeonFloors) then
                ConfirmDialog("Next Area?","Would you like to progress to the next area? You will not be able to backtrack!","Continue","Go Back", 
                function()
                    currentRoom = targetRoom
                    ToggleMapFrame(false)
                    OnRoomEnter(targetRoom)
                end,function()
                    
                end)
                return

            else
            --End the dungeon run
            CompleteRun()
            end
        end
        currentRoom = targetRoom
        ToggleMapFrame(false)
        FadeScreen(true,1.0)
        DCEI.Wait(1)
        OnRoomEnter(targetRoom)
    elseif(battleOngoing == true) then
        DCEI.LogMessage("Couldnt go to room"..targetRoom.." because battle is ongoing!")
    elseif(AreRoomsAdjacent(targetRoom,currentRoom) == false) then
        ShowErrorText("Must target adjacent room!")
    end
end

function IncreasePlayerThreat(modifyValue)
    threatLevel = threatLevel + modifyValue
    ShowRelevantText("<color=red>+ "..modifyValue.."% Threat")
    UpdateMapPanel()
end

function DecreasePlayerThreat(modifyValue)
    threatLevel = threatLevel - modifyValue
    ShowRelevantText("<color=green>- "..modifyValue.."% Threat!")
    UpdateMapPanel()
end

local hasGivenBacktrackWarning = false
function OnRoomEnter(value)
    local roomType = GetRoomType(value)
    finished = false
    battleOngoing = false
    FadeScreen(false,1.0)
    --DCEI.Wait(1.0)
    if(HasRoomBeenVisited(value) and roomType ~= "Nightmare") then
        willBeAmbushed = RandomChance(GetAmbushChance())
        if(willBeAmbushed) then
            GenerateEncounter((currentDungeonLevel * 0.7), nil, false, true)
            ShowOverheadMessage("AMBUSH!",3,{252/255, 57/255,3/255, 255/255})
            CreateCombatDialog()
            
        else
            --ShowRelevantText("+Threat")
            
            IncreasePlayerThreat(GetRandomNumber(4+currentFloor,8+currentFloor))
            if(hasGivenBacktrackWarning == false) then
                hasGivenBacktrackWarning = true
                DCEI.ShowMessageWithButtonText("Backtracking", "You're visiting a room you've already been to. You should be careful when doing this however, as this will generate additional Threat.", "Understood.")
                DCEI.ShowMessageWithButtonText("Backtracking", "If your Threat is high enough, your party could get ambushed when backtracking. Ambush encounters get harder the higher your Threat is!", "Understood.")
            end
            OnShoppingEnded()
        end
    else
        --threatLevel = threatLevel + 2
        if(roomType == "Combat") then
            GenerateEncounter(currentDungeonLevel)
            if(roomsCleared == 1) then
                hasRepositioned = false
                DCEI.ShowMessageWithButtonText("Danger!","Oh no! One of your units is standing in a <color=red>danger zone.</color> Any units standing on danger zones will continuously take damage.", "Continue")
                DCEI.ShowMessageWithButtonText("Repositioning", "Before the battle starts, you can reposition your heroes on the field by <color=yellow>clicking and dragging</color> them to any other hex grid space.", "Got it!")
                DCEI.ShowMessageWithButtonText("Repositioning", "Try moving your units out of danger zones.", "Will do.")
                CreateCombatDialog(false)
                DCEI.SetActive(startCombatButton, false)
                repositionModeActive = true
                HandleRepositionMode()
                
                
                DCEI.LogMessage("Starting reposition checks.")
                --[[while(hasRepositioned == false) do
                    DCEI.Wait(0.25)
                    DCEI.LogMessage("Waiting for reposition!")
                end]]
                DCEI.LogMessage("Reposition completed!")
                DCEI.SetActive(startCombatButton, true)
                repositionModeActive = true
                HandleRepositionMode()
                
            elseif(roomsCleared == 2) then
                DCEI.ShowMessageWithButtonText("Inspecting Enemies", "Before starting a battle, you can click on enemy units to view information about their special abilities, if any.", "Next")
                DCEI.ShowMessageWithButtonText("Inspecting Enemies", "Pay attention to enemies, as some enemies may require different tactics to deal with them effectively.", "Got it!")
                --DCEI.SetActive(startCombatButton, false)
                
                CreateCombatDialog()

            elseif(roomsCleared == 3) then
                DCEI.ShowMessageWithButtonText("Brawler Bonus", "You now have 3 heroes, and each of them has a <color=red>Brawler</color> affinity. On the left you can now see this affinity is active, and your team is receiving its bonus.", "Got it!")
                
                CreateCombatDialog()
                
            else
                CreateCombatDialog()
            end
            
            
        elseif(roomType == "Elite") then 
            GenerateEncounter(2+(currentDungeonLevel*1.25),nil,true)
            CreateCombatDialog()
        elseif(roomType == "Nightmare") then 
            GenerateEncounter(4+(currentDungeonLevel*1.5),nil,false,false,true)
            ShowOverheadMessage("Nightmare!",3,{74/255, 0/255,171/255, 255/255})
            CreateCombatDialog()
            
        elseif(roomType == "Shop") then 
            DCEI.Wait(1.0)
            if(roomsCleared <= 4) then
                DCEI.ShowMessageWithButtonText("Item Shop", "You can purchase additional consumable items at the shop using gold.", "Next")
                DCEI.ShowMessageWithButtonText("Item Shop", "The items offered rotates each time you visit a shop room, so be sure to check multiple shops for sales on different items.", "Got it.")
            end
            CreateShopDialog()
        elseif(roomType == "Event") then 
            DCEI.Wait(1.0)
            ShowEvent(GetRandomEvent())
        elseif(roomType == "Campsite") then
            DCEI.Wait(1.0) 
            CreateThreeChoiceDialog("Campsite","You've arrived at a campsite! Choose an action.",
            {"Rest", "Train","Scout"},
            {"Restore 20% of HP to all heroes.", "For 1 battle, all heroes deal 20% more damage and generate double XP.","Reveal all rooms on this floor. If all rooms are already revealed, reduce your threat by 20%."}, 
            {
                function()
                    ExecuteCampsiteDecision(1)
                end,
                function()
                    ExecuteCampsiteDecision(2)
                end,
                function()
                    ExecuteCampsiteDecision(3)
                end
    
            }
            
            )
        elseif(roomType == "Stairs") then 
            DCEI.ShowMessageWithButtonText("Map Floors", "You've entered a new area! This is another section of the map with a different room layout.\n\nWhen you switch areas, you reduce your current Threat level.", "Next")
            DCEI.ShowMessageWithButtonText("Finishing a Run", "Because this is the final area, moving to the exit room will end the run.", "Got it.")
            exploredRooms = {}
            clearedRooms = {}
            if(roomsClearedThisFloor <= 5 and dungeonData.difficulty > 3) then
                IncreaseDungeonLevel()
                IncreaseDungeonLevel()
            end
            IncreaseDungeonLevel()
            --IncreaseDungeonLevel()
            --IncreaseDungeonLevel()
            CreateMapPanel(currentFloor+1)
            OnShoppingEnded()
            
            
        elseif(roomType == "Treasure") then 
            local loot = GetLoot(currentDungeonLevel,true)
            CreateLootDialog(loot, function()
                OnShoppingEnded()
                UpdateGoldPanel()
                --ShowRelevantText("+Threat")
                IncreasePlayerThreat(5)
                --threatLevel = threatLevel + 2
            end)
            
        end
        
        if(roomType ~= "Stairs") then
            ExploreRoom(value)
        end
    end
    
    --
end

function GetAmbushChance()
    if(threatLevel < 30) then
        return threatLevel / 6
    elseif(threatLevel <= 115) then
        return threatLevel / 2
    else
        return threatLevel * 0.75
    end

    
end

function ExecuteCampsiteDecision(decisionID)
    if(decisionID == 1) then
        for index=1,PARTY_SIZE do
            if(partyUnitHealth[index] ~= nil and partyUnitHealth[index] > 0) then
                local maxHP = DCEI.UnitTypeHealth(partyUnits[index])
                local restoredHP = math.floor( maxHP * 0.2 ) 
                partyUnitHealth[index] = partyUnitHealth[index] + restoredHP
            end
        end
    elseif(decisionID == 2) then
        doublePower = true
        lastStandActive = true
    else
        local revealedRooms = 0
        foreach(map, function(room)
            if(IsRoomExplored(room) == false) then
                revealedRooms = revealedRooms + 1
            end
            ExploreRoom(room)
            

        end)
        if(revealedRooms == 0) then
            DecreasePlayerThreat(20)
        end
        DCEI.ShowFeedbackMessage("All rooms explored!")
    end
    IncreaseDungeonLevel()
    OnShoppingEnded()
end

function HasRoomBeenVisited(room)
    return TableContains(clearedRooms,room)
end

function GetThreatDescText()
    if(threatLevel < 30) then
        return "<color=#d6e792>Threat: "..(threatLevel).."% (Low)"
    elseif(threatLevel >= 30 and threatLevel <= 60) then
        return "<color=#eedc8b>Threat: "..(threatLevel).."% (Medium)"
    elseif(threatLevel >= 60 and threatLevel <= 100) then
        return "<color=#e67651>Threat: "..(threatLevel).."% (High)"
    elseif(threatLevel >= 100) then
        return "<color=#e65151>Threat: "..(threatLevel).."% (High Alert!)"
    end 

    return ""
end

function UpdateMapPanel()
    if(threatPanelText == nil) then return end
    threatLevel = math.floor(threatLevel)
    --local currentIndicatorTargetPos = GetButtonPosition(currentRoom)
    --DCEI.SetHorizontalOffsetInParent(currentRoomIndicator, currentIndicatorTargetPos.x)
    --DCEI.SetVerticalOffsetInParent(currentRoomIndicator, currentIndicatorTargetPos.y )
    --DCEI.Destroy(currentRoomIndicator)
    DCEI.SetText(areaPanelText,"Area: "..(currentFloor).."/"..currentDungeonFloors)
    DCEI.SetText(threatPanelText,GetThreatDescText())
    for index = 1, 25 do
        local imagePath = "icon_enhance_arrowtower_huntersmark"
        local tooltipText = ""
        local bonusTooltipInfo = ""
        if(DoesRoomExist(index)) then
            if(specialRoomModifiers[index] ~= "None") then
                --DCEI.NewHighlight(mapRoomButtons[index])
                if(specialRoomModifiers[index] == "AlertingOthers") then
                    bonusTooltipInfo = "\n<color=yellow>(Alerting Others!) This room is increasing your threat level every turn. Clear it out to cancel this effect."
                end
                if(specialRoomModifiers[index] == "PreparingOthers") then
                    bonusTooltipInfo = "\n<color=yellow>(Preparing Others!) This room is increasing the difficulty of nearby rooms every turn. Clear it out to cancel this effect."
                end
            end
            if(GetRoomType(index) == "Combat") then
                --DCEI.LogMessage("Room: "..index.." is a combat room.")
                imagePath = "icon_enhance_arrowtower_huntersmark"
                tooltipText = "<color=#e3dd30>Fight</color>\nThis room contains a combat encounter.".."\n<color=yellow>Difficulty: "..roomDifficulty[index]..bonusTooltipInfo
            end
            if(GetRoomType(index) == "Shop") then
                imagePath = "shopRoom"
                tooltipText = "<color=#e3dd30>Shop Area</color>\nMove here to purchase items."
            end
            if(GetRoomType(index) == "Treasure") then
                imagePath = "treasureRoom"
                tooltipText = "<color=#e3dd30>Treasure Room</color>\nThis room contains rare treasure."
            end
            if(GetRoomType(index) == "Elite") then
                imagePath = "eliteFightIcon"
                tooltipText = "<color=#e3dd30>Elite Fight</color>\nThis room contains harder than normal enemies, but also better loot.".."\n<color=yellow>Difficulty: "..roomDifficulty[index]..bonusTooltipInfo
            end
            if(GetRoomType(index) == "Nightmare") then
                --DCEI.LogMessage("Room: "..index.." is a nightmare room.")
                imagePath = "icon_enhance_darkspire_torment"
                tooltipText = "<color=#e3dd30>Nightmare Fight</color>\nThis room contains extremely difficult enemies. It should probably be avoided.".."\n<color=red>Difficulty: "..20
            end
            if(GetRoomType(index) == "Event") then
                imagePath = "eventRoom"
                tooltipText = "<color=#e3dd30>Event</color>\nMoving to this area will trigger a random event."
            end
            if(GetRoomType(index) == "Campsite") then
                imagePath = "icon_ingame_campfire"
                tooltipText = "<color=#e3dd30>Campsite</color>\nThis area allows you to heal your heroes, or prepare them for future battles."
            end
            if(GetRoomType(index) == "Stairs") then
                imagePath = "icon_ingame_towerslot_upgrade"
                tooltipText = "<color=#e3dd30>Passage</color>\nThis room allows you to move to the next area of this dungeon."
            end
            if(IsRoomExplored(index) == false) then
                imagePath = "hiddenRoom"
                tooltipText = "<color=#e3dd30>???</color>\nThis room's type is unknown."
            end
            if(HasRoomBeenVisited(index) == true and GetRoomType(index) ~= "Nightmare" and index ~= currentRoom) then
                imagePath = "emptyRoom"
                tooltipText = "<color=#e3dd30>Visited Room</color>\nYou have visited this room. If you return to it, you have a chance to be ambushed."
            end
            if(currentRoom == index) then
                imagePath = "icon_spell_holy_avengers"
            end
            if(index == currentRoom) then
                imagePath = "emptyRoomWithStar"
                tooltipText = "Current Room\nYou are here."
                --DCEI.EnableButton(mapRoomButtons[index],false)
            else
                DCEI.EnableButton(mapRoomButtons[index],true)
            end
            
            DCEI.SetTooltipText(mapRoomButtons[index], tooltipText)
            DCEI.SetBackgroundImage(mapRoomButtons[index], imagePath)
        end
        
    end
end

function OnBehaviorUpdate(behaviorName, unitLink, added)
    UpdateBuffBar(unitLink)
    ExecuteAfter(function()
        UpdateBuffBar(unitLink)
    end,1)
    if(behaviorName == "Block") then
        UpdateBlockBar(unitLink)
    end
    
end

function ExecuteAfter(callback, secondsDelay)
    DCEI.TriggerAddTimerEventElapsed(callback, secondsDelay)
end

RegisterHexs()
ClearAllUnits()
DCEI.LogMessage("Triggers initialized.")
-- INITIALIZE

--DCEI.TriggerAddUnitSelectedEvent(DCEI.UnitAny,OnHeroUnitSelected)
DCEI.TriggerAddCastAbilityEvent(DCEI.UnitAny,OnAnyAbilityUsed)
DCEI.TriggerAddDeactivateAbilityEvent(DCEI.UnitAny, function()
    --DCEI.LogMessage("Deactivate abil event called!")
    if(targetingModeActive == true) then
        ClearTargetingMode()
    end
end)
DCEI.TriggerAddUnitDiedEvent(DCEI.UnitAny,OnUnitDied)
DCEI.TriggerAddMouseDownEvent(0,OnMouseDown)
DCEI.TriggerAddMouseDownEvent(1,OnRightMouseDown)

DCEI.TriggerAddMouseUpEvent(0,OnMouseRelease)
DCEI.TriggerAddMouseUpEvent(1,OnRightMouseRelease)
DCEI.TriggerAddEffectEvent("OnEliteDeath", OnEliteDeath)
DCEI.TriggerAddEffectEvent("AI_Cast_Deathcall", AICastDeathcall)
DCEI.TriggerAddEffectEvent("AI_OozeSplit", AICastOozeSplit)
DCEI.TriggerAddEffectEvent("AI_WitchHex", AICastWitchHex)
DCEI.TriggerAddEffectEvent("Brew Potion", BrewPotionCasted)

DCEI.TriggerAddTextCommandEvent(OnCheatEntered)
DCEI.TriggerAddUnitSpawnEvent(DCEI.UnitAny, function()
    local tUnit = DCEI.TriggeringUnit
    --DCEI.LogMessage("Got Unit spawn name:"..DCEI.UnitName(tUnit))
    if(IsHelperUnit(tUnit) == false and DCEI.GetUnitTeamId(tUnit) == -1 and DCEI.UnitType(tUnit) == "Unit") then
        --DCEI.LogMessage("Creating Unit Bar for:"..DCEI.UnitName(tUnit))
        CreateUnitBar(tUnit,true)
    end
end,true)
DCEI.TriggerAddTimerEventPeriodicIndefinite(CheckPowerGains, 3, true)
DCEI.TriggerAddTimerEventPeriodicIndefinite(CheckMapVisibleLoop, 2, true)

DCEI.TriggerAddBehaviorAddEvent(DCEI.UnitAny, function()
    local behavior = DCEI.TriggeringBehaviorName
    local tUnit = DCEI.TriggeringUnit
    OnBehaviorUpdate(behavior,tUnit, true)

end)

DCEI.TriggerAddBehaviorExpireEvent(DCEI.UnitAny, function()
    local behavior = DCEI.TriggeringBehaviorName
    local tUnit = DCEI.TriggeringUnit
    OnBehaviorUpdate(behavior,tUnit, false)

end)


ExecuteAfter(function ()
    --ShowErrorText("You can't do that right now!")
    DCEI.Wait(1)
    
end,6)
--SpawnHeroes()
PauseAllUnits()
--

CreateInventoryFrame()
CreateGoldPanel()
CreateAffinityFrame()
UpdateInventoryUI()
--CreateLootDialog(GetLoot(currentDungeonLevel))
SetDefaultSpawns()

--CreatePerkDialog(GetRandomPerksToShow(),function() end)
UpdateGoldPanel()
CreateMapPanel(1)
UpdateMapPanel()
CreatePowerBar()
DCEI.SetCameraVisibleAreaCenter(12,20.8)
--CreateEndRunButton()
--FadeScreen(true,3)




ToggleMapFrame(false)
--CreateTeamViewDialog()
UpdateActiveAffinities()

function StartGame()
    if(testMode == true) then
        --ToggleMapFrame(true)
        --CreateTeamViewDialog()
        --CreateShopDialog()
        
        --ConfirmDialog()
        --ToggleMapFrame(false)
        --AddItem("Poison Potion",6)
        --AddItem("Mobility Potion",10)
        AddItem(GetRandomAffinityTome(),1)
        AddItem(GetRandomAffinityTome(),1)
        AddItem(GetRandomAffinityTome(),1)
        for index=1,(GetTableSize(AFFINITIES)-2) do
            
         end
        --[[ToggleMapFrame(false)]]
        PresentHeroChoice(GetRandomChoosableHeroes(),
        function ()
            --GenerateEncounter(1,{"Deathspeaker"})
           -- GenerateEncounter(1,{"Warthog","Bone Warrior"})
            --CreateShopDialog()
            ShowEvent(gameEvents[testEventID])
            if(settings.helpTips == true) then
                DCEI.ShowMessageWithButtonText("Combat", "Before combat, you can click on enemy units to see their special abilities and traits.\n\nOptionally, you can also reposition your units before every battle by clicking the reposition button in the lower right, then clicking and dragging on the unit you want to move. Positioning is key to protecting key units, or avoiding dangerous enemies.", "Got it!")  
            end
            
        end
        )
    else
        ToggleMapFrame(false)
        --DCEI.ShowMessageWithButtonText("Welcome!", "Your run begins! Here we'll take some time to go over the basics of exploring a dungeon.", "Let's Go!")

        --DCEI.ShowMessageWithButtonText("Draft A Hero", "First, you'll need to choose a hero! Periodically you'll get to draft a hero into your team; for now, let's pick a Berserker.", "Draft Hero")
        DCEI.ShowPositionHelper(6.3,17.65)
        GenerateEncounter(1,{"Dorgarian Mercenary","Dorgarian Mercenary"})
        
        ToggleHexGrid(false)
        CreateCombatDialog(false)
        
        
        --[[PresentHeroChoice(GetRandomChoosableHeroes(),
        function ()
            --GenerateEncounter(1,{"Deathspeaker"})
            
            


        end
        )]]
    end
end

--[[if(DCEI.Save.Get("MissionsPlayed") < 2) then
    ConfirmDialog("Enable Help Tips?","It looks like you might be new! Would you like to enable help tips?","Yes!","No thanks.",function()
        settings.helpTips = true
        DCEI.ShowMessageWithButtonText("Your Party", "Start by choosing a hero! Each hero has a unique trait, and a unique ability you can activate in combat.", "Got it!")  
        StartGame()
    end,function()
        settings.helpTips = false
        StartGame()
    end)
else
    settings.helpTips = false
    StartGame()
end]]
--[[]]


--DCEI.TriggerAddUnitSelectedEvent(party[2],OnHeroUnitSelected)
function OnMapStart()
    core.HideDefaultUi()
    math.randomseed( os.time() )
    local emptyPoint = DCEI.GetUnitPosition2D(ITEM_CASTER)
    foreach(HERO_TYPES, function(heroObject)
        local createdUnit = DCEI.CreateUnitWithFacing(1, 1, heroObject.name, emptyPoint.x, emptyPoint.y, 0, 0)
        DCEI.Wait(0)
        --DCEI.ApplyBehavior("Paused",createdUnit)
        ExecuteAfter(function()
            foreach(AFFINITIES, function(affinity)
                if(affinity.name ~= "Bonus" and affinity.name ~= "Nightmare" and DCEI.UnitBehaviorStackCount(createdUnit, affinity.name) >= 1) then
                    --DCEI.LogMessage("Recognized affinity: "..affinity.name.." on hero: "..heroObject.name)
                    table.insert(heroObject.affinities, affinity)
                    DCEI.RemoveUnit(createdUnit)
                end
            end)
        end,0.1)
    end)
    settings.helpTips = false
    ExecuteAfter(function()
        StartGame()
    end,.1)
    
end

DCEI.TriggerAddTimerEventElapsed(OnMapStart, 0)